---
url: https://medium.com/pinterest-engineering/analyzing-distributed-trace-data-6aae58919949
title: Analyzing distributed trace data - Pinterest Engineering Blog - Medium
archived_at: 2021-05-23T00:58:47.773009+08:00
---
<div id="readability-page-1" class="page"><div><div><p><a rel="noopener" href="https://medium.com/@Pinterest_Engineering?source=post_page-----6aae58919949--------------------------------"><img alt="Pinterest Engineering" src="https://miro.medium.com/fit/c/96/96/1*FNWs-r9nA_QNtBbYvUkAtg.png" width="48" height="48"/></a></p></div><p id="f68f">Brittany Herr | Pinterest engineering intern <br/>Naoman Abbas | Pinterest engineer, Visibility</p><p id="3ba7">Earlier this year we open sourced <a rel="noopener" href="https://medium.com/@Pinterest_Engineering/distributed-tracing-at-pinterest-with-new-open-source-tools-a4f8a5562f6b">Pintrace</a>, a distributed tracing pipeline. A trace follows a request as it moves through a backend, tracking where and how it spends its time. Traces are made up of spans, each of which represents an operation. At Pinterest, there are tens of services and hundreds of network calls per-trace. The information from distributed tracing provides deep visibility into what goes on in our backend and helps identify bottlenecks .</p><p id="e5de">However, one trace isn’t representative of the thousands of traces logged each minute (let alone the millions of requests per minute these traces are sampled from). Additionally, any single trace could have been an outlier or logged incorrectly. When it comes to assessing the overall performance of the Pinterest backend, we need to use trace data in a way that gives us a much bigger picture. That’s why we built the Pintrace Trace Analyzer, which performs an aggregated analysis of traces. Looking at stats from thousands of traces over a longer period of time not only weeds out the outliers/buggy traces, but provides a holistic view of performance.</p><figure><div role="button" tabindex="0"><p><img alt="" src="https://miro.medium.com/max/3200/0*E1dNgwllZsUSFnat." width="1600" height="1022" role="presentation"/></p></div><figcaption><em>Waterfall diagram depicting a single trace. Each row is a span: in each span, the light blue block represents the time taken for that span, and the dark blue label has the service name.</em></figcaption></figure><h2 id="67bd"><strong>Pintrace Trace Analyzer</strong></h2><p id="eb21">The power of this tool is its ability to compare two batches of traces — displaying stats for each of the two and highlighting the changes. An unexpected and significant change in a metric can indicate that something’s going wrong in a deployment. We focused on two indicators for Pintrace Trace Analyzer:</p><ol><li id="9816">Per-service latency: how long a service takes to perform its operation.</li><li id="a0eb">Number of network calls: how many times a service was called.</li></ol><p id="fee1">A significant (and unexpected) change in either of these could mean an error in the code which could cause a production issue, resulting in increased wait times for Pinners. Seeing the changes in latency patterns or spikes in network calls backed by information from thousands of traces can shed light on areas of concern in the production code.</p><h2 id="a902"><strong>How it works</strong></h2><p id="eb8f">With this tool, an engineer can hone in on these problem areas by comparing two different groups of traces, as specified by the user. “Different” here can mean:</p><ul><li id="182b">Different time periods, i.e. before and after a deployment or incident.</li><li id="3363">Across different devices, e.g. web and iOS.</li><li id="62f7">From different countries.</li><li id="88fd">Types of requests, e.g. v3_home_feed and v3_get_pin</li></ul><p id="a0b9">The Trace Analyzer consists of two main parts–a <a href="https://spark.apache.org/" rel="noopener nofollow">Spark</a> job (for high-capacity data processing) and a <a href="http://jupyter.org/" rel="noopener nofollow">Jupyter</a> notebook UI.</p><figure><div><p><img alt="" src="https://miro.medium.com/max/786/0*lkJEUYSf_RhaiJII." width="393" height="336" srcset="https://miro.medium.com/max/552/0*lkJEUYSf_RhaiJII. 276w, https://miro.medium.com/max/786/0*lkJEUYSf_RhaiJII. 393w" sizes="393px" role="presentation" data-old-src="https://miro.medium.com/max/60/0*lkJEUYSf_RhaiJII.?q=20"/></p></div><figcaption><em>Workflow of Trace Analyzer. Blue components were built in this project and grey components already existed as part of Pintrace.</em></figcaption></figure><ol><li id="fb01">The user enters two sets of trace specifications into the Jupyter interface.</li><li id="1cd7">A Python script posts the Spark job to <a href="https://mesos.github.io/chronos/" rel="noopener nofollow">Chronos</a> with the user parameters.</li><li id="6482">The Spark job pulls span data from <a href="https://www.elastic.co/products/elasticsearch" rel="noopener nofollow">Elasticsearch</a>.</li><li id="98b3">The job runs the analysis and pushes the results to Elasticsearch.</li><li id="51a0">Jupyter pulls the results from Elasticsearch and displays the visual report for the user.</li></ol><p id="5256">These are a few example diagrams generated by the report:</p><figure><div role="button" tabindex="0"><p><img alt="" src="https://miro.medium.com/max/2232/0*JkCaJ3z0jEALQS2R." width="1116" height="438" srcset="https://miro.medium.com/max/552/0*JkCaJ3z0jEALQS2R. 276w, https://miro.medium.com/max/1104/0*JkCaJ3z0jEALQS2R. 552w, https://miro.medium.com/max/1280/0*JkCaJ3z0jEALQS2R. 640w, https://miro.medium.com/max/1400/0*JkCaJ3z0jEALQS2R. 700w" sizes="700px" role="presentation" data-old-src="https://miro.medium.com/max/60/0*JkCaJ3z0jEALQS2R.?q=20"/></p></div><figcaption><em>Overview table comparing two batches of traces.</em></figcaption></figure><figure><div role="button" tabindex="0"><p><img alt="" src="https://miro.medium.com/max/1664/0*yGcolJu0c--_R0oV." width="832" height="572" srcset="https://miro.medium.com/max/552/0*yGcolJu0c--_R0oV. 276w, https://miro.medium.com/max/1104/0*yGcolJu0c--_R0oV. 552w, https://miro.medium.com/max/1280/0*yGcolJu0c--_R0oV. 640w, https://miro.medium.com/max/1400/0*yGcolJu0c--_R0oV. 700w" sizes="700px" role="presentation" data-old-src="https://miro.medium.com/max/60/0*yGcolJu0c--_R0oV.?q=20"/></p></div><figcaption><em>Histogram showing overall latency for traces in each batch.</em></figcaption></figure><figure><div role="button" tabindex="0"><p><img alt="" src="https://miro.medium.com/max/1900/0*qZoQnGVg7bmd7L17." width="950" height="428" srcset="https://miro.medium.com/max/552/0*qZoQnGVg7bmd7L17. 276w, https://miro.medium.com/max/1104/0*qZoQnGVg7bmd7L17. 552w, https://miro.medium.com/max/1280/0*qZoQnGVg7bmd7L17. 640w, https://miro.medium.com/max/1400/0*qZoQnGVg7bmd7L17. 700w" sizes="700px" role="presentation" data-old-src="https://miro.medium.com/max/60/0*qZoQnGVg7bmd7L17.?q=20"/></p></div><figcaption><em>Sample traces (trace ID and value) for various percentiles that link to the traces in Pintrace.</em></figcaption></figure><h2 id="c583"><strong>What this means for us</strong></h2><p id="3846">This tool more efficiently and effectively targets sources of concern and reduces latency incidents. We ran a comparison report on trace data for a specific date (with bad performance) against a normal performance.</p><figure><div><p><img alt="" src="https://miro.medium.com/max/1144/0*rZrWbZdoRoRN-5JS." width="572" height="214" srcset="https://miro.medium.com/max/552/0*rZrWbZdoRoRN-5JS. 276w, https://miro.medium.com/max/1104/0*rZrWbZdoRoRN-5JS. 552w, https://miro.medium.com/max/1144/0*rZrWbZdoRoRN-5JS. 572w" sizes="572px" role="presentation" data-old-src="https://miro.medium.com/max/60/0*rZrWbZdoRoRN-5JS.?q=20"/></p></div><figcaption><em>Overview table that shows a huge latency increase.</em></figcaption></figure><p id="79cf">The below table breaks down number of RPCs per service, we found a spike in number of calls for the service “pinandboardservice.”</p><figure><div role="button" tabindex="0"><p><img alt="" src="https://miro.medium.com/max/1466/0*jO2UofOhPMjpVoup." width="733" height="606" srcset="https://miro.medium.com/max/552/0*jO2UofOhPMjpVoup. 276w, https://miro.medium.com/max/1104/0*jO2UofOhPMjpVoup. 552w, https://miro.medium.com/max/1280/0*jO2UofOhPMjpVoup. 640w, https://miro.medium.com/max/1400/0*jO2UofOhPMjpVoup. 700w" sizes="700px" role="presentation" data-old-src="https://miro.medium.com/max/60/0*jO2UofOhPMjpVoup.?q=20"/></p></div></figure><p id="3536">This indicated unnecessary calls to an API which slowed down requests. With information like this, we can quickly detect the source of an issue and fix any bugs.</p><h2 id="9a6d"><strong>Future steps</strong></h2><p id="7a09">We’ve used this tool after incidents to identify where an error occurred and diagnose what happened . We’re eager to continue exploring future extensions with Pintrace as this is only the tip of the distributed tracing iceberg. Some other possible use cases are:</p><ul><li id="fd89">Integrating it with our deployment process to detect whether a new version of the app will cause performance issues. This would allow us to use the tool as a preventative measure rather than passively as a debugging tool.</li><li id="a8b0">Automatically generating reports so engineers can easily check the status of each day’s deployments.</li><li id="ea72">Setting up alerts for when latency or number of RPC hits a certain threshold.</li></ul><p id="2233">The use cases for this tool will expand as the instrumentation of our traces expands. For example, we plan to add versioning or experiment information to each trace, so we can compare stats across these differentiators.</p><p id="6793">What we’ve implemented so far establishes the base of aggregate trace analysis. By adding extensions to this project, we’ll be able to further leverage trace data to ultimately provide Pinners with a faster experience.</p><figure><div><p><img alt="" src="https://miro.medium.com/max/72/1*qyJBXP1N7G1uBMgx93slhg.png" width="36" height="37" role="presentation" data-old-src="https://miro.medium.com/max/58/1*qyJBXP1N7G1uBMgx93slhg.png?q=20"/></p></div></figure></div></div>