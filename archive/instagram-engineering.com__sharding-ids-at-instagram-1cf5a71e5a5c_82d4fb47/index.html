---
url: https://instagram-engineering.com/sharding-ids-at-instagram-1cf5a71e5a5c
title: Sharding & IDs at Instagram - Instagram Engineering
archived_at: 2024-04-17T01:12:28.388704411+08:00
---
<div id="readability-page-1" class="page"><div><div><a href="https://medium.com/@InstagramEng?source=post_page-----1cf5a71e5a5c--------------------------------" rel="noopener follow"><div aria-hidden="false"><p><img alt="Instagram Engineering" src="https://miro.medium.com/v2/resize:fill:88:88/1*8x_1IP3b75o5u9M4LgFBig.jpeg" width="44" height="44" loading="lazy" data-testid="authorPhoto"/></p></div></a><a href="https://instagram-engineering.com/?source=post_page-----1cf5a71e5a5c--------------------------------" rel="noopener  ugc nofollow"><div aria-hidden="false"><p><img alt="Instagram Engineering" src="https://miro.medium.com/v2/resize:fill:48:48/1*CPgwLHR6jno_tOmF0--7eg.jpeg" width="24" height="24" loading="lazy" data-testid="publicationPhoto"/></p></div></a></div><p id="da79">With more than 25 photos and 90 likes every second, we store a lot of data here at Instagram. To make sure all of our important data fits into memory and is available quickly for our users, we’ve begun to <a href="http://www.facebook.com/l.php?u=http%3A%2F%2Fen.wikipedia.org%2Fwiki%2FShard_%28database%29&amp;h=lAQHFITrt&amp;s=1" rel="noopener ugc nofollow" target="_blank">shard</a> our data — in other words, place the data in many smaller buckets, each holding a part of the data.</p><p id="bfba">Our application servers run <a href="http://www.facebook.com/l.php?u=http%3A%2F%2Fdjangoproject.com%2F&amp;h=sAQHcqWJT&amp;s=1" rel="noopener ugc nofollow" target="_blank">Django</a> with <a href="http://www.facebook.com/l.php?u=http%3A%2F%2Fpostgresql.org%2F&amp;h=iAQGuql57&amp;s=1" rel="noopener ugc nofollow" target="_blank">PostgreSQL</a> as our back-end database. Our first question after deciding to shard out our data was whether PostgreSQL should remain our primary data-store, or whether we should switch to something else. We evaluated a few different NoSQL solutions, but ultimately decided that the solution that best suited our needs would be to shard our data across a set of PostgreSQL servers.</p><p id="6dec">Before writing data into this set of servers, however, we had to solve the issue of how to assign unique identifiers to each piece of data in the database (for example, each photo posted in our system). The typical solution that works for a single database — just using a database’s natural auto-incrementing primary key feature — no longer works when data is being inserted into many databases at the same time. The rest of this blog post addresses how we tackled this issue.</p><p id="33d5">Before starting out, we listed out what features were essential in our system:</p><ol><li id="1012">Generated IDs should be sortable by time (so a list of photo IDs, for example, could be sorted without fetching more information about the photos)</li><li id="4d7d">IDs should ideally be 64 bits (for smaller indexes, and better storage in systems like Redis)</li><li id="be99">The system should introduce as few new ‘moving parts’ as possible — a large part of how we’ve been able to scale Instagram with very few engineers is by choosing simple, easy-to-understand solutions that we trust.</li></ol><p id="b933">Many existing solutions to the ID generation problem exist; here are a few we considered:</p><h2 id="60a6">Generate IDs in web application</h2><p id="c629">This approach leaves ID generation entirely up to your application, and not up to the database at all. For example, <a href="http://www.facebook.com/l.php?u=http%3A%2F%2Fwww.mongodb.org%2Fdisplay%2FDOCS%2FObject%2BIDs&amp;h=fAQFgEvBI&amp;s=1" rel="noopener ugc nofollow" target="_blank">MongoDB’s ObjectId</a>, which is 12 bytes long and encodes the timestamp as the first component. Another popular approach is to use <a href="http://www.facebook.com/l.php?u=http%3A%2F%2Fen.wikipedia.org%2Fwiki%2FUniversally_unique_identifier&amp;h=MAQFZAMfT&amp;s=1" rel="noopener ugc nofollow" target="_blank">UUIDs</a>.</p><p id="cac7"><strong>Pros:</strong></p><ol><li id="825c">Each application thread generates IDs independently, minimizing points of failure and contention for ID generation</li><li id="8e47">If you use a timestamp as the first component of the ID, the IDs remain time-sortable</li></ol><p id="78ab"><strong>Cons:</strong></p><ol><li id="3488">Generally requires more storage space (96 bits or higher) to make reasonable uniqueness guarantees</li><li id="132d">Some UUID types are completely random and have no natural sort</li></ol><h2 id="1dfc">Generate IDs through dedicated service</h2><p id="18ec">Ex: Twitter’s <a href="http://www.facebook.com/l.php?u=http%3A%2F%2Fgithub.com%2Ftwitter%2Fsnowflake%2F&amp;h=9AQHsyMKM&amp;s=1" rel="noopener ugc nofollow" target="_blank">Snowflake</a>, a Thrift service that uses Apache ZooKeeper to coordinate nodes and then generates 64-bit unique IDs</p><p id="56bb"><strong>Pros:</strong></p><ol><li id="57bf">Snowflake IDs are 64-bits, half the size of a UUID</li><li id="da49">Can use time as first component and remain sortable</li><li id="1754">Distributed system that can survive nodes dying</li></ol><p id="6714"><strong>Cons:</strong></p><ol><li id="4ec6">Would introduce additional complexity and more ‘moving parts’ (ZooKeeper, Snowflake servers) into our architecture</li></ol><h2 id="360d">DB Ticket Servers</h2><p id="1ed8">Uses the database’s auto-incrementing abilities to enforce uniqueness. <a href="http://www.facebook.com/l.php?u=http%3A%2F%2Fcode.flickr.com%2Fblog%2F2010%2F02%2F08%2Fticket-servers-distributed-unique-primary-keys-on-the-cheap%2F&amp;h=xAQEgbGg0&amp;s=1" rel="noopener ugc nofollow" target="_blank">Flickr uses this approach</a>, but with two ticket DBs (one on odd numbers, the other on even) to avoid a single point of failure.</p><p id="21fa"><strong>Pros:</strong></p><ol><li id="2efa">DBs are well understood and have pretty predictable scaling factors</li></ol><p id="1cfc"><strong>Cons:</strong></p><ol><li id="5459">Can eventually become a write bottleneck (though Flickr reports that, even at huge scale, it’s not an issue).</li><li id="f344">An additional couple of machines (or EC2 instances) to admin</li><li id="ad41">If using a single DB, becomes single point of failure. If using multiple DBs, can no longer guarantee that they are sortable over time.</li></ol><p id="1ed1">Of all the approaches above, Twitter’s Snowflake came the closest, but the additional complexity required to run an ID service was a point against it. Instead, we took a conceptually similar approach, but brought it inside PostgreSQL.</p><p id="058c">Our sharded system consists of several thousand ‘logical’ shards that are mapped in code to far fewer physical shards. Using this approach, we can start with just a few database servers, and eventually move to many more, simply by moving a set of logical shards from one database to another, without having to re-bucket any of our data. We used Postgres’ schemas feature to make this easy to script and administrate.</p><p id="a766">Schemas (not to be confused with the SQL schema of an individual table) are a logical grouping feature in Postgres. Each Postgres DB can h2have several schemas, each of which can contain one or more tables. Table names must only be unique per-schema, not per-DB, and by default Postgres places everything in a schema named ‘public’.</p><p id="2f83">Each ‘logical’ shard is a Postgres schema in our system, and each sharded table (for example, likes on our photos) exists inside each schema.</p><p id="722a">We’ve delegated ID creation to each table inside each shard, by using PL/PGSQL, Postgres’ internal programming language, and Postgres’ existing auto-increment functionality.</p><p id="b78f">Each of our IDs consists of:</p><ul><li id="8172">41 bits for time in milliseconds (gives us 41 years of IDs with a custom epoch)</li><li id="c457">13 bits that represent the logical shard ID</li><li id="55d4">10 bits that represent an auto-incrementing sequence, modulus 1024. This means we can generate 1024 IDs, per shard, per millisecond</li></ul><p id="ddb7">Let’s walk through an example: let’s say it’s September 9th, 2011, at 5:00pm and our ‘epoch’ begins on January 1st, 2011. There have been 1387263000 milliseconds since the beginning of our epoch, so to start our ID, we fill the left-most 41 bits with this value with a left-shift:</p><pre><span id="9940">id = 1387263000 &lt;&lt;(64-41)</span></pre><p id="f8be">Next, we take the shard ID for this particular piece of data we’re trying to insert. Let’s say we’re sharding by user ID, and there are 2000 logical shards; if our user ID is 31341, then the shard ID is 31341 % 2000 -&gt; 1341. We fill the next 13 bits with this value:</p><pre><span id="d0ff">id |= 1341 &lt;&lt;(64-41-13)</span></pre><p id="983e">Finally, we take whatever the next value of our auto-increment sequence (this sequence is unique to each table in each schema) and fill out the remaining bits. Let’s say we’d generated 5,000 IDs for this table already; our next value is 5,001, which we take and mod by 1024 (so it fits in 10 bits) and include it too:</p><pre><span id="1364">id |= (5001 % 1024)</span></pre><p id="1ed9">We now have our ID, which we can return to the application server using the RETURNING keyword as part of the INSERT.</p><p id="ff0d">Here’s the PL/PGSQL that accomplishes all this (for an example schema insta5):</p><pre><span id="fc17">CREATE OR REPLACE FUNCTION insta5.next_id(OUT result bigint) AS $$<br/>DECLARE<br/>    our_epoch bigint := 1314220021721;<br/>    seq_id bigint;<br/>    now_millis bigint;<br/>    shard_id int := 5;<br/>BEGIN<br/>    SELECT nextval(&#39;insta5.table_id_seq&#39;) %% 1024 INTO seq_id;</span><span id="9622">    SELECT FLOOR(EXTRACT(EPOCH FROM clock_timestamp()) * 1000) INTO now_millis;<br/>    result := (now_millis - our_epoch) &lt;&lt; 23;<br/>    result := result | (shard_id &lt;&lt;10);<br/>    result := result | (seq_id);<br/>END;<br/>    $$ LANGUAGE PLPGSQL;</span></pre><p id="c828">And when creating the table, we do:</p><pre><span id="f4da">CREATE TABLE insta5.our_table (<br/>    &#34;id&#34; bigint NOT NULL DEFAULT insta5.next_id(),<br/>    ...rest of table schema...<br/>  )</span></pre><p id="33af">And that’s it! Primary keys that are unique across our application (and as a bonus, contain the shard ID in them for easier mapping). We’ve been rolling this approach into production and are happy with the results so far. Interested in helping us figure out these problems at scale? <a href="http://www.facebook.com/l.php?u=http%3A%2F%2Finstagram.com%2Fabout%2Fjobs%2F&amp;h=MAQFZAMfT&amp;s=1" rel="noopener ugc nofollow" target="_blank">We’re hiring!</a></p><p id="f3ef"><em>Discuss this post on </em><a href="http://www.facebook.com/l.php?u=http%3A%2F%2Fnews.ycombinator.com%2Fitem%3Fid%3D3058327&amp;h=AAQGg9bLp&amp;s=1" rel="noopener ugc nofollow" target="_blank"><em>Hacker News</em></a><em>.</em></p></div></div>