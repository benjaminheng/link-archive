---
url: https://netflixtechblog.com/lessons-from-building-observability-tools-at-netflix-7cfafed6ab17
title: Lessons from Building Observability Tools at Netflix
archived_at: 2021-05-23T00:58:54.548023+08:00
---
<div id="readability-page-1" class="page"><div><div><p><a href="https://netflixtechblog.medium.com/?source=post_page-----7cfafed6ab17--------------------------------" rel="noopener"><img alt="Netflix Technology Blog" src="https://miro.medium.com/fit/c/96/96/1*BJWRqfSMf9Da9vsXG9EBRQ.jpeg" width="48" height="48"/></a></p></div><p id="7f28">Our mission at Netflix is to deliver joy to our members by providing high-quality content, presented with a delightful experience. We are constantly innovating on our product at a rapid pace in pursuit of this mission. Our innovations span personalized title recommendations, infrastructure, and application features like downloading and customer profiles. Our growing global member base of 125 million members can choose to enjoy our service on over a thousand types of devices. If you also consider the scale and variety of content, maintaining the quality of experience for all our members is an interesting challenge. We tackle that challenge by developing <em>observability tools</em> and infrastructure to measure customers’ experiences and analyze those measurements to derive meaningful insights and higher-level conclusions from raw data. By <em>observability</em>, we mean analysis of logs, traces, and metrics. In this post, we share the following lessons we have learned:</p><ul><li id="57ef">At some point in business growth, we learned that storing raw application logs won’t scale. To address scalability, we switched to streaming logs, filtering them on selected criteria, transforming them in memory, and persisting them as needed.</li><li id="c06d">As applications migrated to having a microservices architecture, we needed a way to gain insight into the complex decisions that microservices were making. Distributed request tracing is a start, but is not sufficient to fully understand application behavior and reason about issues. Augmenting the request trace with application context and intelligent conclusions is also necessary.</li><li id="2fe3">Besides analysis of logging and request traces, observability also includes analysis of metrics. By exploring metrics anomaly detection and metrics correlation, we’ve learned how to define actionable alerting beyond just threshold alerting.</li><li id="0f1f">Our observability tools need to access various persisted data types. Choosing which kind of database to store a given data type depends on how each particular data type is written and retrieved.</li><li id="4384">Data presentation requirements vary widely between teams and users. It is critical to understand your users and deliver views tailored to a user’s profile.</li></ul><p id="93ae">We started our tooling efforts with providing visibility into device and server logs, so that our users can go to one tool instead of having to use separate data-specific tools or logging into servers. Providing visibility into logs is valuable because log messages include important contextual information, especially when errors occur.</p><p id="4317">However, at some point in our business growth, storing device and server logs didn’t scale because the increasing volume of log data caused our storage cost to balloon and query times to increase. Besides reducing our storage retention time period, we addressed scalability by implementing a real-time stream processing platform called <a href="https://medium.com/netflix-techblog/stream-processing-with-mantis-78af913f51a6" rel="noopener">Mantis</a>. Instead of saving all logs to persistent storage, Mantis enables our users to stream logs into memory, and keep only those logs that match SQL-like query criteria. Users also have the choice to transform and save matching logs to persistent storage. A query that retrieves a sample of playback start events for the Apple iPad is shown in the following screenshot:</p><figure><div role="button" tabindex="0"><p><img alt="" src="https://miro.medium.com/max/3200/0*05M3O_9OoM8lc3rt" width="1600" height="594" srcset="https://miro.medium.com/max/552/0*05M3O_9OoM8lc3rt 276w, https://miro.medium.com/max/1104/0*05M3O_9OoM8lc3rt 552w, https://miro.medium.com/max/1280/0*05M3O_9OoM8lc3rt 640w, https://miro.medium.com/max/1400/0*05M3O_9OoM8lc3rt 700w" sizes="700px" role="presentation" data-old-src="https://miro.medium.com/max/60/0*05M3O_9OoM8lc3rt?q=20"/></p></div><figcaption>Mantis query results for sample playback start events</figcaption></figure><p id="d2c1">Once a user obtains an initial set of samples, they can iteratively refine their queries to narrow down the specific set of samples. For example, perhaps the root cause of an issue is found from only samples in a specific country. In this case, the user can submit another query to retrieve samples from that country.</p><p id="43ef">The key takeaway is that storing all logs in persistent storage won’t scale in terms of cost and acceptable query response time. An architecture that leverages real-time event streams and provides the ability to quickly and iteratively identify the relevant subset of logs is one way to address this problem.</p><p id="f978">As applications migrated to a microservices architecture, we needed insight into the complex decisions that microservices are making, and an approach that would correlate those decisions. Inspired by Google’s <a href="https://research.google.com/pubs/pub36356.html" rel="noopener">Dapper paper</a> on distributed request tracing, we embarked on implementing request tracing as a way to address this need. Since most inter-process communication uses HTTP and <a href="https://grpc.io/docs/guides/" rel="noopener">gRPC</a> (with the trend for newer services to use gRPC to benefit from its binary protocol), we implemented request interceptors for HTTP and gRPC calls. These interceptors publish trace data to Apache Kafka, and a consuming process writes trace data to persistent storage.</p><p id="e56d">The following screenshot shows a sample request trace in which a single request results in calling a second tier of servers, one of which calls a third-tier of servers:</p><figure><div role="button" tabindex="0"><p><img alt="" src="https://miro.medium.com/max/2214/1*ENqhPgT6utTs56XmIu8WLw.png" width="1107" height="441" srcset="https://miro.medium.com/max/552/1*ENqhPgT6utTs56XmIu8WLw.png 276w, https://miro.medium.com/max/1104/1*ENqhPgT6utTs56XmIu8WLw.png 552w, https://miro.medium.com/max/1280/1*ENqhPgT6utTs56XmIu8WLw.png 640w, https://miro.medium.com/max/1400/1*ENqhPgT6utTs56XmIu8WLw.png 700w" sizes="700px" role="presentation" data-old-src="https://miro.medium.com/max/60/1*ENqhPgT6utTs56XmIu8WLw.png?q=20"/></p></div><figcaption>Sample request trace</figcaption></figure><p id="27ba">The smaller squares beneath a server indicate individual operations. Gray-colored servers don’t have tracing enabled.</p><p id="e9cc">A distributed request trace provides only basic utility in terms of showing a call graph and basic latency information. What is unique in our approach is that we allow applications to add additional identifiers to trace data so that multiple traces can be grouped together across services. For example, for playback request traces, all the requests relevant to a given playback session are grouped together by using a playback session identifier. We also implemented additional logic modules called <strong><em>analyzers</em></strong> to answer common troubleshooting questions. Continuing with the above example, questions about a playback session might be why a given session did or did not receive 4K video, or why video was or wasn’t offered with High Dynamic Range.</p><p id="e2d2">Our goal is to increase the effectiveness of our tools by providing richer and more relevant context. We have started implementing machine learning analysis on error logs associated with playback sessions. This analysis does some basic clustering to display any common log attributes, such as Netflix application version number, and we display this information along with the request trace. For example, if a given playback session has an error log, and we’ve noticed that other similar devices have had the same error with the same Netflix application version number, we will display that application version number. Users have found this additional contextual information helpful in finding the root cause of a playback error.</p><p id="733b">In summary, the key learnings from our effort are that tying multiple request traces into a logical concept, a playback session in this case, and providing additional context based on constituent traces enables our users to quickly determine the root cause of a streaming issue that may involve multiple systems. In some cases, we are able to take this a step further by adding logic that determines the root cause and provides an English explanation in the user interface.</p><p id="58d9">Besides analysis of logging and request traces, observability also involves analysis of metrics. Because having users examine many logs is overwhelming, we extended our offering by publishing log error counts to our metrics monitoring system called <a href="https://medium.com/netflix-techblog/introducing-atlas-netflixs-primary-telemetry-platform-bd31f4d8ed9a" rel="noopener">Atlas</a>, which enables our users to quickly see macro-level error trends using multiple dimensions, such as device type and customer geographical location. An alerting system also allows users to receive alerts if a given metric exceeds a defined threshold. In addition, when using Mantis, a user can define metrics derived from matching logs and publish them to Atlas.</p><p id="35a1">Next, we have implemented statistical algorithms to detect anomalies in metrics trends, by comparing the current trend with a baseline trend. We are also working on correlating metrics for related microservices. From our work with anomaly detection and metrics correlation, we’ve learned how to define actionable alerting beyond just basic threshold alerting. In a future blog post, we’ll discuss these efforts.</p><p id="1a3e">We store data used by our tools in Cassandra, Elasticsearch, and Hive. We chose a specific database based primarily on how our users want to retrieve a given data type, and the write rate. For observability data that is always retrieved by primary key and a time range, we use Cassandra. When data needs to be queried by one or more fields, we use Elasticsearch since multiple fields within a given record can be easily indexed. Finally, we observed that recent data, such as up to the last week, is accessed more frequently than older data, since most of our users troubleshoot recent issues. To serve the use case where someone wants to access older data, we also persist the same logs in Hive but for a longer time period.</p><p id="03fc">Cassandra, Elasticsearch, and Hive have their own advantages and disadvantages in terms of cost, latency, and queryability. <a href="https://docs.datastax.com/en/cassandra/3.0/cassandra/dml/dmlIntro.html" rel="noopener">Cassandra</a> provides the best, highest per-record write and read rates, but is restrictive for reads because you must decide what to use for a row key (a unique identifier for a given record) and within each row, what to use for a column key, such as a timestamp. In contrast, Elasticsearch and Hive provide more flexibility with reads because Elasticsearch allows you to index any field within a record, and Hive’s SQL-like query language allows you to match against any field within a record. However, since Elasticsearch is primarily optimized for free text search, its indexing overhead during writes will demand more computing nodes as write rate increases. For example, for one of our observability data sets, we initially stored data in Elasticsearch to be able to easily index more than one field per record, but as the write rate increased, indexing time became long enough that either the data wasn’t available when users queried for it, or it took too long for data to be returned. As a result, we migrated to Cassandra, which had shorter write ingestion time and shorter data retrieval time, but we defined data retrieval for the three unique keys that serve our current data retrieval use cases.</p><p id="efe7">For Hive, since records are stored in files, reads are relatively much slower than Cassandra and Elasticsearch because Hive must scan files. Regarding storage and computing cost, Hive is the cheapest because multiple records can be kept in a single file, and data isn’t replicated. Elasticsearch is most likely the next more expensive option, depending on the write ingestion rate. Elasticsearch can also be configured to have <a href="https://www.elastic.co/guide/en/elasticsearch/guide/current/replica-shards.html" rel="noopener">replica shards</a> to enable higher read throughput. Cassandra is most likely the most expensive, since it encourages replicating each record to <a href="https://docs.datastax.com/en/cassandra/3.0/cassandra/architecture/archDataDistributeReplication.html?hl=data%2Creplication" rel="noopener">more than one replica</a> in order to ensure reliability and fault tolerance.</p><p id="c220">As usage of our observability tools grows, users have been continually asking for new features. Some of those new feature requests involve displaying data in a view customized for specific user groups, such as device developers, server developers, and Customer Service. On a given page in one of our tools, some users want to see all types of data that the page offers, whereas other users want to see only a subset of the total data set. We addressed this requirement by making the page customizable via persisted user preferences. For example, in a given table of data, users want the ability to choose which columns they want to see. To meet this requirement, for each user, we store a list of visible columns for that table. Another example involves a log type with large payloads. Loading those logs for a customer account increases the page loading time. Since only a subset of users are interested in this log type, we made loading these logs a user preference.</p><p id="efb8">Examining a given log type may require domain expertise that not all users may have. For example, for a given log from a Netflix device, understanding the data in the log requires knowledge of some identifiers, error codes, and some string keys. Our tools try to minimize the specialized knowledge required to effectively diagnose problems by joining identifiers with the data they refer to, and providing descriptions of error codes and string keys.</p><p id="380e">In short, our learning here is that customized views and helpful context provided by visualizations that surface relevant information are critical in communicating insights effectively to our users.</p><p id="6d16">Our observability tools have empowered many teams within Netflix to better understand the experience we are delivering to our customers and quickly troubleshoot issues across various facets such as devices, titles, geographical location, and client app version. Our tools are now an essential part of the operational and debugging toolkit for our engineers. As Netflix evolves and grows, we want to continue to provide our engineers with the ability to innovate rapidly and bring joy to our customers. In future blog posts, we will dive into technical architecture, and we will share our results from some of our ongoing efforts such as metrics analysis and using machine learning for log analysis.</p><p id="22dc">If any of this work sounds exciting to you, please <a href="https://jobs.netflix.com/search?q=%22edge%20insights%22" rel="noopener">reach out</a> to us!</p><p id="6905">— Kevin Lew (@kevinlew15) and Sangeeta Narayanan (@sangeetan)</p><figure><div role="button" tabindex="0"><p><img alt="" src="https://miro.medium.com/max/1720/1*qpKlpxWko8OSApsBq2FPRA.png" width="860" height="450" srcset="https://miro.medium.com/max/552/1*qpKlpxWko8OSApsBq2FPRA.png 276w, https://miro.medium.com/max/1104/1*qpKlpxWko8OSApsBq2FPRA.png 552w, https://miro.medium.com/max/1280/1*qpKlpxWko8OSApsBq2FPRA.png 640w, https://miro.medium.com/max/1400/1*qpKlpxWko8OSApsBq2FPRA.png 700w" sizes="700px" role="presentation" data-old-src="https://miro.medium.com/max/60/1*qpKlpxWko8OSApsBq2FPRA.png?q=20"/></p></div></figure></div></div>