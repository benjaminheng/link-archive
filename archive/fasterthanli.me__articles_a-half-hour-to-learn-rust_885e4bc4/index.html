---
url: https://fasterthanli.me/articles/a-half-hour-to-learn-rust
title: A half-hour to learn Rust
archived_at: 2021-12-13T16:00:37.926532+08:00
---
<div id="readability-page-1" class="page"><div>
  

  <p>
    Jan 27, 2020
    
      · 51 minute read
    
    
    
      
        
          ·
          <a href="https://fasterthanli.me/tags/rust">rust</a>
        
      
      
      
      
          
      
      
    
  </p>

  
</div><div>
  

  <p>In order to increase fluency in a programming language, one has to read a lot of it.
But how can you read a lot of it if you don&#39;t know what it means?</p>
<p>In this article, instead of focusing on one or two concepts, I&#39;ll try to go
through as many Rust snippets as I can, and explain what the keywords and symbols
they contain mean.</p>
<p>Ready? Go!</p>
<p><code>let</code> introduces a variable binding:</p>
<pre><p>Rust code</p><p><code><i>let</i> x<i>;</i> <i>// declare &#34;x&#34;</i>
x = <i>42</i><i>;</i> <i>// assign 42 to &#34;x&#34;</i>
</code></p></pre>
<p>This can also be written as a single line:</p>
<pre><p>Rust code</p><p><code><i>let</i> x = <i>42</i><i>;</i>
</code></p></pre>
<p>You can specify the variable&#39;s type explicitly with <code>:</code>, that&#39;s a type annotation:</p>
<pre><p>Rust code</p><p><code><i>let</i> x: <i>i32</i><i>;</i> <i>// `i32` is a signed 32-bit integer</i>
x = <i>42</i><i>;</i>

<i>// there&#39;s i8, i16, i32, i64, i128</i>
<i>//    also u8, u16, u32, u64, u128 for unsigned</i>
</code></p></pre>
<p>This can also be written as a single line:</p>
<pre><p>Rust code</p><p><code><i>let</i> x: <i>i32</i> = <i>42</i><i>;</i>
</code></p></pre>
<p>If you declare a name and initialize it later, the compiler will prevent you
from using it before it&#39;s initialized.</p>
<pre><p>Rust code</p><p><code><i>let</i> x<i>;</i>
<i>foobar</i><i>(</i>x<i>)</i><i>;</i> <i>// error: borrow of possibly-uninitialized variable: `x`</i>
x = <i>42</i><i>;</i>
</code></p></pre>
<p>However, doing this is completely fine:</p>
<pre><p>Rust code</p><p><code><i>let</i> x<i>;</i>
x = <i>42</i><i>;</i>
<i>foobar</i><i>(</i>x<i>)</i><i>;</i> <i>// the type of `x` will be inferred from here</i>
</code></p></pre>
<p>The underscore <code>_</code> is a special name - or rather, a &#34;lack of name&#34;. It
basically means to throw away something:</p>
<pre><p>Rust code</p><p><code><i>// this does *nothing* because 42 is a constant</i>
<i>let</i> _ = <i>42</i><i>;</i>

<i>// this calls `get_thing` but throws away its result</i>
<i>let</i> _ = <i>get_thing</i><i>(</i><i>)</i><i>;</i>
</code></p></pre>
<p>Names that <em>start</em> with an underscore are regular names, it&#39;s just that
the compiler won&#39;t warn about them being unused:</p>
<pre><p>Rust code</p><p><code><i>// we may use `_x` eventually, but our code is a work-in-progress</i>
<i>// and we just wanted to get rid of a compiler warning for now.</i>
<i>let</i> _x = <i>42</i><i>;</i>
</code></p></pre>
<p>Separate bindings with the same name can be introduced - you can <em>shadow</em>
a variable binding:</p>
<pre><p>Rust code</p><p><code><i>let</i> x = <i>13</i><i>;</i>
<i>let</i> x = x + <i>3</i><i>;</i>
<i>// using `x` after that line only refers to the second `x`,</i>
<i>// the first `x` no longer exists.</i>
</code></p></pre>
<p>Rust has tuples, which you can think of as &#34;fixed-length collections
of values of different types&#34;.</p>
<pre><p>Rust code</p><p><code><i>let</i> pair = <i>(</i><i>&#39;a&#39;</i>, <i>17</i><i>)</i><i>;</i>
pair<i>.</i><i>0</i><i>;</i> <i>// this is &#39;a&#39;</i>
pair<i>.</i><i>1</i><i>;</i> <i>// this is 17</i>
</code></p></pre>
<p>If we really wanted to annotate the type of <code>pair</code>, we would write:</p>
<pre><p>Rust code</p><p><code><i>let</i> pair: <i>(</i><i>char</i>, <i>i32</i><i>)</i> = <i>(</i><i>&#39;a&#39;</i>, <i>17</i><i>)</i><i>;</i>
</code></p></pre>
<p>Tuples can be <em>destructured</em> when doing an assignment, which means
they&#39;re broken down into their individual fields:</p>
<pre><p>Rust code</p><p><code><i>let</i> <i>(</i>some_char, some_int<i>)</i> = <i>(</i><i>&#39;a&#39;</i>, <i>17</i><i>)</i><i>;</i>
<i>// now, `some_char` is &#39;a&#39;, and `some_int` is 17</i>
</code></p></pre>
<p>This is especially useful when a function returns a tuple:</p>
<pre><p>Rust code</p><p><code><i>let</i> <i>(</i>left, right<i>)</i> = slice<i>.</i><i>split_at</i><i>(</i>middle<i>)</i><i>;</i>
</code></p></pre>
<p>Of course, when destructuring a tuple, <code>_</code> can be used to throw away part of it:</p>
<pre><p>Rust code</p><p><code><i>let</i> <i>(</i>_, right<i>)</i> = slice<i>.</i><i>split_at</i><i>(</i>middle<i>)</i><i>;</i>
</code></p></pre>
<p>The semi-colon marks the end of a statement:</p>
<pre><p>Rust code</p><p><code><i>let</i> x = <i>3</i><i>;</i>
<i>let</i> y = <i>5</i><i>;</i>
<i>let</i> z = y + x<i>;</i>
</code></p></pre>
<p>Which means statements can span multiple lines:</p>
<pre><p>Rust code</p><p><code><i>let</i> x = <i>vec</i><i>!</i><i>[</i><i>1</i>, <i>2</i>, <i>3</i>, <i>4</i>, <i>5</i>, <i>6</i>, <i>7</i>, <i>8</i><i>]</i>
    <i>.</i><i>iter</i><i>(</i><i>)</i>
    <i>.</i><i>map</i><i>(</i>|x| x + <i>3</i><i>)</i>
    <i>.</i><i>fold</i><i>(</i><i>0</i>, |x, y| x + y<i>)</i><i>;</i>
</code></p></pre>
<p>(We&#39;ll go over what those actually mean later).</p>
<p><code>fn</code> declares a function.</p>
<p>Here&#39;s a void function:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>greet</i><i>(</i><i>)</i> {
    <i>println</i><i>!</i><i>(</i><i>&#34;Hi there!&#34;</i><i>)</i><i>;</i>
}
</code></p></pre>
<p>And here&#39;s a function that returns a 32-bit signed integer. The
arrow indicates its return type:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>fair_dice_roll</i><i>(</i><i>)</i> -&gt; <i>i32</i> {
    <i>4</i>
}
</code></p></pre>
<p>A pair of brackets declares a block, which has its own scope:</p>
<pre><p>Rust code</p><p><code><i>// This prints &#34;in&#34;, then &#34;out&#34;</i>
<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> x = <i>&#34;out&#34;</i><i>;</i>
    {
        <i>// this is a different `x`</i>
        <i>let</i> x = <i>&#34;in&#34;</i><i>;</i>
        <i>println</i><i>!</i><i>(</i><i>&#34;{}&#34;</i>, x<i>)</i><i>;</i>
    }
    <i>println</i><i>!</i><i>(</i><i>&#34;{}&#34;</i>, x<i>)</i><i>;</i>
}
</code></p></pre>
<p>Blocks are also expressions, which mean they evaluate to.. a value.</p>
<pre><p>Rust code</p><p><code><i>// this:</i>
<i>let</i> x = <i>42</i><i>;</i>

<i>// is equivalent to this:</i>
<i>let</i> x = { <i>42</i> }<i>;</i>
</code></p></pre>
<p>Inside a block, there can be multiple statements:</p>
<pre><p>Rust code</p><p><code><i>let</i> x = {
    <i>let</i> y = <i>1</i><i>;</i> <i>// first statement</i>
    <i>let</i> z = <i>2</i><i>;</i> <i>// second statement</i>
    y + z <i>// this is the *tail* - what the whole block will evaluate to</i>
}<i>;</i>
</code></p></pre>
<p>And that&#39;s why &#34;omitting the semicolon at the end of a function&#34; is the same
as returning, ie. these are equivalent:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>fair_dice_roll</i><i>(</i><i>)</i> -&gt; <i>i32</i> {
    <i>return</i> <i>4</i><i>;</i>
}

<i>fn</i> <i>fair_dice_roll</i><i>(</i><i>)</i> -&gt; <i>i32</i> {
    <i>4</i>
}
</code></p></pre>
<p><code>if</code> conditionals are also expressions:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>fair_dice_roll</i><i>(</i><i>)</i> -&gt; <i>i32</i> {
    <i>if</i> feeling_lucky {
        <i>6</i>
    } <i>else</i> {
        <i>4</i>
    }
}
</code></p></pre>
<p>A <code>match</code> is also an expression:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>fair_dice_roll</i><i>(</i><i>)</i> -&gt; <i>i32</i> {
    <i>match</i> feeling_lucky {
        <i>true</i> =&gt; <i>6</i>,
        <i>false</i> =&gt; <i>4</i>,
    }
}
</code></p></pre>
<p>Dots are typically used to access fields of a value:</p>
<pre><p>Rust code</p><p><code><i>let</i> a = <i>(</i><i>10</i>, <i>20</i><i>)</i><i>;</i>
a<i>.</i><i>0</i><i>;</i> <i>// this is 10</i>

<i>let</i> amos = <i>get_some_struct</i><i>(</i><i>)</i><i>;</i>
amos<i>.</i><i>nickname</i><i>;</i> <i>// this is &#34;fasterthanlime&#34;</i>
</code></p></pre>
<p>Or call a method on a value:</p>
<pre><p>Rust code</p><p><code><i>let</i> nick = <i>&#34;fasterthanlime&#34;</i><i>;</i>
nick<i>.</i><i>len</i><i>(</i><i>)</i><i>;</i> <i>// this is 14</i>
</code></p></pre>
<p>The double-colon, <code>::</code>, is similar but it operates on namespaces.</p>
<p>In this example, <code>std</code> is a <em>crate</em> (~ a library), <code>cmp</code> is a <em>module</em>
(~ a source file), and <code>min</code> is a <em>function</em>:</p>
<pre><p>Rust code</p><p><code><i>let</i> least = std<i>::</i>cmp<i>::</i><i>min</i><i>(</i><i>3</i>, <i>8</i><i>)</i><i>;</i> <i>// this is 3</i>
</code></p></pre>
<p><code>use</code> directives can be used to &#34;bring in scope&#34; names from other
namespace:</p>
<pre><p>Rust code</p><p><code><i>use</i> std<i>::</i>cmp<i>::</i>min<i>;</i>

<i>let</i> least = <i>min</i><i>(</i><i>7</i>, <i>1</i><i>)</i><i>;</i> <i>// this is 1</i>
</code></p></pre>
<p>Within <code>use</code> directives, curly brackets have another meaning: they&#39;re
&#34;globs&#34;. If we want to import both <code>min</code> and <code>max</code>, we can do any
of these:</p>
<pre><p>Rust code</p><p><code><i>// this works:</i>
<i>use</i> std<i>::</i>cmp<i>::</i>min<i>;</i>
<i>use</i> std<i>::</i>cmp<i>::</i>max<i>;</i>

<i>// this also works:</i>
<i>use</i> std<i>::</i>cmp<i>::</i>{min, max}<i>;</i>

<i>// this also works!</i>
<i>use</i> std<i>::</i>{cmp<i>::</i>min, cmp<i>::</i>max}<i>;</i>
</code></p></pre>
<p>A wildcard (<code>*</code>) lets you import every symbol from a namespace:</p>
<pre><p>Rust code</p><p><code><i>// this brings `min` and `max` in scope, and many other things</i>
<i>use</i> std<i>::</i>cmp<i>::</i><i>*</i><i>;</i>
</code></p></pre>
<p>Types are namespaces too, and methods can be called as regular functions:</p>
<pre><p>Rust code</p><p><code><i>let</i> x = <i>&#34;amos&#34;</i><i>.</i><i>len</i><i>(</i><i>)</i><i>;</i> <i>// this is 4</i>
<i>let</i> x = str<i>::</i><i>len</i><i>(</i><i>&#34;amos&#34;</i><i>)</i><i>;</i> <i>// this is also 4</i>
</code></p></pre>
<p><code>str</code> is a primitive type, but many non-primitive types are also in scope
by default.</p>
<pre><p>Rust code</p><p><code><i>// `Vec` is a regular struct, not a primitive type</i>
<i>let</i> v = <i>Vec</i><i>::</i><i>new</i><i>(</i><i>)</i><i>;</i>

<i>// this is exactly the same code, but with the *full* path to `Vec`</i>
<i>let</i> v = std<i>::</i>vec<i>::</i><i>Vec</i><i>::</i><i>new</i><i>(</i><i>)</i><i>;</i>
</code></p></pre>
<p>This works because Rust inserts this at the beginning of every module:</p>
<pre><p>Rust code</p><p><code><i>use</i> std<i>::</i>prelude<i>::</i>v1<i>::</i><i>*</i><i>;</i>
</code></p></pre>
<p>(Which in turns re-exports a lot of symbols, like <code>Vec</code>, <code>String</code>, <code>Option</code> and <code>Result</code>).</p>
<p>Structs are declared with the <code>struct</code> keyword:</p>
<pre><p>Rust code</p><p><code><i>struct</i> <i>Vec2</i> {
    <i>x</i>: <i>f64</i>, <i>// 64-bit floating point, aka &#34;double precision&#34;</i>
    <i>y</i>: <i>f64</i>,
}
</code></p></pre>
<p>They can be initialized using <em>struct literals</em>:</p>
<pre><p>Rust code</p><p><code><i>let</i> v1 = <i>Vec2</i> { <i>x</i>: <i>1.0</i>, <i>y</i>: <i>3.0</i> }<i>;</i>
<i>let</i> v2 = <i>Vec2</i> { <i>y</i>: <i>2.0</i>, <i>x</i>: <i>4.0</i> }<i>;</i>
<i>// the order does not matter, only the names do</i>
</code></p></pre>
<p>There is a shortcut for initializing the <em>rest of the fields</em> from
another struct:</p>
<pre><p>Rust code</p><p><code><i>let</i> v3 = <i>Vec2</i> {
    <i>x</i>: <i>14.0</i>,
    ..v2
}<i>;</i>
</code></p></pre>
<p>This is called &#34;struct update syntax&#34;, can only happen in last position,
and cannot be followed by a comma.</p>
<p>Note that <em>the rest of the fields</em> can mean <em>all the fields</em>:</p>
<pre><p>Rust code</p><p><code><i>let</i> v4 = <i>Vec2</i> { ..v3 }<i>;</i>
</code></p></pre>
<p>Structs, like tuples, can be destructured.</p>
<p>Just like this is a valid <code>let</code> pattern:</p>
<pre><p>Rust code</p><p><code><i>let</i> <i>(</i>left, right<i>)</i> = slice<i>.</i><i>split_at</i><i>(</i>middle<i>)</i><i>;</i>
</code></p></pre>
<p>So is this:</p>
<pre><p>Rust code</p><p><code><i>let</i> v = <i>Vec2</i> { <i>x</i>: <i>3.0</i>, <i>y</i>: <i>6.0</i> }<i>;</i>
<i>let</i> <i>Vec2</i> { x, y } = v<i>;</i>
<i>// `x` is now 3.0, `y` is now `6.0`</i>
</code></p></pre>
<p>And this:</p>
<pre><p>Rust code</p><p><code><i>let</i> <i>Vec2</i> { x, .. } = v<i>;</i>
<i>// this throws away `v.y`</i>
</code></p></pre>
<p><code>let</code> patterns can be used as conditions in <code>if</code>:</p>
<pre><p>Rust code</p><p><code><i>struct</i> <i>Number</i> {
    <i>odd</i>: <i>bool</i>,
    <i>value</i>: <i>i32</i>,
}

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> one = <i>Number</i> { <i>odd</i>: <i>true</i>, <i>value</i>: <i>1</i> }<i>;</i>
    <i>let</i> two = <i>Number</i> { <i>odd</i>: <i>false</i>, <i>value</i>: <i>2</i> }<i>;</i>
    <i>print_number</i><i>(</i>one<i>)</i><i>;</i>
    <i>print_number</i><i>(</i>two<i>)</i><i>;</i>
}

<i>fn</i> <i>print_number</i><i>(</i><i>n</i>: <i>Number</i><i>)</i> {
    <i>if</i> <i>let</i> <i>Number</i> { <i>odd</i>: <i>true</i>, value } = n {
        <i>println</i><i>!</i><i>(</i><i>&#34;Odd number: {}&#34;</i>, value<i>)</i><i>;</i>
    } <i>else</i> <i>if</i> <i>let</i> <i>Number</i> { <i>odd</i>: <i>false</i>, value } = n {
        <i>println</i><i>!</i><i>(</i><i>&#34;Even number: {}&#34;</i>, value<i>)</i><i>;</i>
    }
}

<i>// this prints:</i>
<i>// Odd number: 1</i>
<i>// Even number: 2</i>
</code></p></pre>
<p><code>match</code> arms are also patterns, just like <code>if let</code>:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>print_number</i><i>(</i><i>n</i>: <i>Number</i><i>)</i> {
    <i>match</i> n {
        <i>Number</i> { <i>odd</i>: <i>true</i>, value } =&gt; <i>println</i><i>!</i><i>(</i><i>&#34;Odd number: {}&#34;</i>, value<i>)</i>,
        <i>Number</i> { <i>odd</i>: <i>false</i>, value } =&gt; <i>println</i><i>!</i><i>(</i><i>&#34;Even number: {}&#34;</i>, value<i>)</i>,
    }
}

<i>// this prints the same as before</i>
</code></p></pre>
<p>A <code>match</code> has to be exhaustive: at least one arm needs to match.</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>print_number</i><i>(</i><i>n</i>: <i>Number</i><i>)</i> {
    <i>match</i> n {
        <i>Number</i> { <i>value</i>: <i>1</i>, .. } =&gt; <i>println</i><i>!</i><i>(</i><i>&#34;One&#34;</i><i>)</i>,
        <i>Number</i> { <i>value</i>: <i>2</i>, .. } =&gt; <i>println</i><i>!</i><i>(</i><i>&#34;Two&#34;</i><i>)</i>,
        <i>Number</i> { value, .. } =&gt; <i>println</i><i>!</i><i>(</i><i>&#34;{}&#34;</i>, value<i>)</i>,
        <i>// if that last arm didn&#39;t exist, we would get a compile-time error</i>
    }
}
</code></p></pre>
<p>If that&#39;s hard, <code>_</code> can be used as a &#34;catch-all&#34; pattern:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>print_number</i><i>(</i><i>n</i>: <i>Number</i><i>)</i> {
    <i>match</i> n<i>.</i><i>value</i> {
        <i>1</i> =&gt; <i>println</i><i>!</i><i>(</i><i>&#34;One&#34;</i><i>)</i>,
        <i>2</i> =&gt; <i>println</i><i>!</i><i>(</i><i>&#34;Two&#34;</i><i>)</i>,
        _ =&gt; <i>println</i><i>!</i><i>(</i><i>&#34;{}&#34;</i>, n.value<i>)</i>,
    }
}
</code></p></pre>
<p>You can declare methods on your own types:</p>
<pre><p>Rust code</p><p><code><i>struct</i> <i>Number</i> {
    <i>odd</i>: <i>bool</i>,
    <i>value</i>: <i>i32</i>,
}

<i>impl</i> <i>Number</i> {
    <i>fn</i> <i>is_strictly_positive</i><i>(</i><i>self</i><i>)</i> -&gt; <i>bool</i> {
        <i>self</i><i>.</i><i>value</i> &gt; <i>0</i>
    }
}
</code></p></pre>
<p>And use them like usual:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> minus_two = <i>Number</i> {
        <i>odd</i>: <i>false</i>,
        <i>value</i>: -<i>2</i>,
    }<i>;</i>
    <i>println</i><i>!</i><i>(</i><i>&#34;positive? {}&#34;</i>, minus_two.is_strictly_positive<i>(</i><i>)</i><i>)</i><i>;</i>
    <i>// this prints &#34;positive? false&#34;</i>
}
</code></p></pre>
<p>Variable bindings are immutable by default, which means their
interior can&#39;t be mutated:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> n = <i>Number</i> {
        <i>odd</i>: <i>true</i>,
        <i>value</i>: <i>17</i>,
    }<i>;</i>
    n<i>.</i><i>odd</i> = <i>false</i><i>;</i> <i>// error: cannot assign to `n.odd`,</i>
                   <i>// as `n` is not declared to be mutable</i>
}
</code></p></pre>
<p>And also that they cannot be assigned to:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> n = <i>Number</i> {
        <i>odd</i>: <i>true</i>,
        <i>value</i>: <i>17</i>,
    }<i>;</i>
    n = <i>Number</i> {
        <i>odd</i>: <i>false</i>,
        <i>value</i>: <i>22</i>,
    }<i>;</i> <i>// error: cannot assign twice to immutable variable `n`</i>
}
</code></p></pre>
<p><code>mut</code> makes a variable binding mutable:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> <i>mut</i> n = <i>Number</i> {
        <i>odd</i>: <i>true</i>,
        <i>value</i>: <i>17</i>,
    }
    n<i>.</i><i>value</i> = <i>19</i><i>;</i> <i>// all good</i>
}
</code></p></pre>
<p>Traits are something multiple types can have in common:</p>
<pre><p>Rust code</p><p><code><i>trait</i> <i>Signed</i> {
    <i>fn</i> <i>is_strictly_negative</i><i>(</i><i>self</i><i>)</i> -&gt; <i>bool</i><i>;</i>
}
</code></p></pre>
<p>You can implement:</p>
<ul>
<li>one of your traits on anyone&#39;s type</li>
<li>anyone&#39;s trait on one of your types</li>
<li>but not a foreign trait on a foreign type</li>
</ul>
<p>These are called the &#34;orphan rules&#34;.</p>
<p>Here&#39;s an implementation of our trait on our type:</p>
<pre><p>Rust code</p><p><code><i>impl</i> <i>Signed</i> <i>for</i> <i>Number</i> {
    <i>fn</i> <i>is_strictly_negative</i><i>(</i><i>self</i><i>)</i> -&gt; <i>bool</i> {
        <i>self</i><i>.</i><i>value</i> &lt; <i>0</i>
    }
}

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> n = <i>Number</i> { <i>odd</i>: <i>false</i>, <i>value</i>: -<i>44</i> }<i>;</i>
    <i>println</i><i>!</i><i>(</i><i>&#34;{}&#34;</i>, n.is_strictly_negative<i>(</i><i>)</i><i>)</i><i>;</i> <i>// prints &#34;true&#34;</i>
}
</code></p></pre>
<p>Our trait on a foreign type (a primitive type, even):</p>
<pre><p>Rust code</p><p><code><i>impl</i> <i>Signed</i> <i>for</i> <i>i32</i> {
    <i>fn</i> <i>is_strictly_negative</i><i>(</i><i>self</i><i>)</i> -&gt; <i>bool</i> {
        <i>self</i> &lt; <i>0</i>
    }
}

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> n: <i>i32</i> = -<i>44</i><i>;</i>
    <i>println</i><i>!</i><i>(</i><i>&#34;{}&#34;</i>, n.is_strictly_negative<i>(</i><i>)</i><i>)</i><i>;</i> <i>// prints &#34;true&#34;</i>
}
</code></p></pre>
<p>A foreign trait on our type:</p>
<pre><p>Rust code</p><p><code><i>// the `Neg` trait is used to overload `-`, the</i>
<i>// unary minus operator.</i>
<i>impl</i> std<i>::</i>ops<i>::</i><i>Neg</i> <i>for</i> <i>Number</i> {
    <i>type</i> <i>Output</i> = <i>Number</i><i>;</i>

    <i>fn</i> <i>neg</i><i>(</i><i>self</i><i>)</i> -&gt; <i>Number</i> {
        <i>Number</i> {
            <i>value</i>: -<i>self</i><i>.</i><i>value</i>,
            <i>odd</i>: <i>self</i><i>.</i><i>odd</i>,
        }        
    }
}

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> n = <i>Number</i> { <i>odd</i>: <i>true</i>, <i>value</i>: <i>987</i> }<i>;</i>
    <i>let</i> m = -n<i>;</i> <i>// this is only possible because we implemented `Neg`</i>
    <i>println</i><i>!</i><i>(</i><i>&#34;{}&#34;</i>, m.value<i>)</i><i>;</i> <i>// prints &#34;-987&#34;</i>
}
</code></p></pre>
<p>An <code>impl</code> block is always <em>for</em> a type, so, inside that block, <code>Self</code>
means that type:</p>
<pre><p>Rust code</p><p><code><i>impl</i> std<i>::</i>ops<i>::</i><i>Neg</i> <i>for</i> <i>Number</i> {
    <i>type</i> <i>Output</i> = <i>Self</i><i>;</i>

    <i>fn</i> <i>neg</i><i>(</i><i>self</i><i>)</i> -&gt; <i>Self</i> {
        <i>Self</i> {
            <i>value</i>: -<i>self</i><i>.</i><i>value</i>,
            <i>odd</i>: <i>self</i><i>.</i><i>odd</i>,
        }        
    }
}
</code></p></pre>
<p>Some traits are <em>markers</em> - they don&#39;t say that a type implements
some methods, they say that certain things can be done with a type.</p>
<p>For example, <code>i32</code> implements trait <code>Copy</code> (in short, <code>i32</code> <em>is</em> <code>Copy</code>),
so this works:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> a: <i>i32</i> = <i>15</i><i>;</i>
    <i>let</i> b = a<i>;</i> <i>// `a` is copied</i>
    <i>let</i> c = a<i>;</i> <i>// `a` is copied again</i>
}
</code></p></pre>
<p>And this also works:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>print_i32</i><i>(</i><i>x</i>: <i>i32</i><i>)</i> {
    <i>println</i><i>!</i><i>(</i><i>&#34;x = {}&#34;</i>, x<i>)</i><i>;</i>
}

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> a: <i>i32</i> = <i>15</i><i>;</i>
    <i>print_i32</i><i>(</i>a<i>)</i><i>;</i> <i>// `a` is copied</i>
    <i>print_i32</i><i>(</i>a<i>)</i><i>;</i> <i>// `a` is copied again</i>
}
</code></p></pre>
<p>But the <code>Number</code> struct is not <code>Copy</code>, so this doesn&#39;t work:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> n = <i>Number</i> { <i>odd</i>: <i>true</i>, <i>value</i>: <i>51</i> }<i>;</i>
    <i>let</i> m = n<i>;</i> <i>// `n` is moved into `m`</i>
    <i>let</i> o = n<i>;</i> <i>// error: use of moved value: `n`</i>
}
</code></p></pre>
<p>And neither does this:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>print_number</i><i>(</i><i>n</i>: <i>Number</i><i>)</i> {
    <i>println</i><i>!</i><i>(</i><i>&#34;{} number {}&#34;</i>, <i>if</i> n.odd { <i>&#34;odd&#34;</i> } else { <i>&#34;even&#34;</i> }, n.value<i>)</i><i>;</i>
}

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> n = <i>Number</i> { <i>odd</i>: <i>true</i>, <i>value</i>: <i>51</i> }<i>;</i>
    <i>print_number</i><i>(</i>n<i>)</i><i>;</i> <i>// `n` is moved</i>
    <i>print_number</i><i>(</i>n<i>)</i><i>;</i> <i>// error: use of moved value: `n`</i>
}
</code></p></pre>
<p>But it works if <code>print_number</code> takes an immutable reference instead:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>print_number</i><i>(</i><i>n</i>: <i>&amp;</i><i>Number</i><i>)</i> {
    <i>println</i><i>!</i><i>(</i><i>&#34;{} number {}&#34;</i>, <i>if</i> n.odd { <i>&#34;odd&#34;</i> } else { <i>&#34;even&#34;</i> }, n.value<i>)</i><i>;</i>
}

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> n = <i>Number</i> { <i>odd</i>: <i>true</i>, <i>value</i>: <i>51</i> }<i>;</i>
    <i>print_number</i><i>(</i><i>&amp;</i>n<i>)</i><i>;</i> <i>// `n` is borrowed for the time of the call</i>
    <i>print_number</i><i>(</i><i>&amp;</i>n<i>)</i><i>;</i> <i>// `n` is borrowed again</i>
}
</code></p></pre>
<p>It also works if a function takes a <em>mutable</em> reference - but only
if our variable binding is also <code>mut</code>.</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>invert</i><i>(</i><i>n</i>: <i>&amp;</i><i>mut</i> <i>Number</i><i>)</i> {
    n<i>.</i><i>value</i> = -n<i>.</i><i>value</i><i>;</i>
}

<i>fn</i> <i>print_number</i><i>(</i><i>n</i>: <i>&amp;</i><i>Number</i><i>)</i> {
    <i>println</i><i>!</i><i>(</i><i>&#34;{} number {}&#34;</i>, <i>if</i> n.odd { <i>&#34;odd&#34;</i> } else { <i>&#34;even&#34;</i> }, n.value<i>)</i><i>;</i>
}

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>// this time, `n` is mutable</i>
    <i>let</i> <i>mut</i> n = <i>Number</i> { <i>odd</i>: <i>true</i>, <i>value</i>: <i>51</i> }<i>;</i>
    <i>print_number</i><i>(</i><i>&amp;</i>n<i>)</i><i>;</i>
    <i>invert</i><i>(</i><i>&amp;</i><i>mut</i> n<i>)</i><i>;</i> <i>// `n is borrowed mutably - everything is explicit</i>
    <i>print_number</i><i>(</i><i>&amp;</i>n<i>)</i><i>;</i>
}
</code></p></pre>
<p>Trait methods can also take <code>self</code> by reference or mutable reference:</p>
<pre><p>Rust code</p><p><code><i>impl</i> std<i>::</i>clone<i>::</i><i>Clone</i> <i>for</i> <i>Number</i> {
    <i>fn</i> <i>clone</i><i>(</i><i>&amp;</i><i>self</i><i>)</i> -&gt; <i>Self</i> {
        <i>Self</i> { ..<i>*</i><i>self</i> }
    }
}
</code></p></pre>
<p>When invoking trait methods, the receiver is borrowed implicitly:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> n = <i>Number</i> { <i>odd</i>: <i>true</i>, <i>value</i>: <i>51</i> }<i>;</i>
    <i>let</i> <i>mut</i> m = n<i>.</i><i>clone</i><i>(</i><i>)</i><i>;</i>
    m<i>.</i><i>value</i> += <i>100</i><i>;</i>
    
    <i>print_number</i><i>(</i><i>&amp;</i>n<i>)</i><i>;</i>
    <i>print_number</i><i>(</i><i>&amp;</i>m<i>)</i><i>;</i>
}
</code></p></pre>
<p>To highlight this: these are equivalent:</p>
<pre><p>Rust code</p><p><code><i>let</i> m = n<i>.</i><i>clone</i><i>(</i><i>)</i><i>;</i>

<i>let</i> m = std<i>::</i>clone<i>::</i><i>Clone</i><i>::</i><i>clone</i><i>(</i><i>&amp;</i>n<i>)</i><i>;</i>
</code></p></pre>
<p>Marker traits like <code>Copy</code> have no methods:</p>
<pre><p>Rust code</p><p><code><i>// note: `Copy` requires that `Clone` is implemented too</i>
<i>impl</i> std<i>::</i>clone<i>::</i><i>Clone</i> <i>for</i> <i>Number</i> {
    <i>fn</i> <i>clone</i><i>(</i><i>&amp;</i><i>self</i><i>)</i> -&gt; <i>Self</i> {
        <i>Self</i> { ..<i>*</i><i>self</i> }
    }
}

<i>impl</i> std<i>::</i>marker<i>::</i><i>Copy</i> <i>for</i> <i>Number</i> {}
</code></p></pre>
<p>Now, <code>Clone</code> can still be used:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> n = <i>Number</i> { <i>odd</i>: <i>true</i>, <i>value</i>: <i>51</i> }<i>;</i>
    <i>let</i> m = n<i>.</i><i>clone</i><i>(</i><i>)</i><i>;</i>
    <i>let</i> o = n<i>.</i><i>clone</i><i>(</i><i>)</i><i>;</i>
}
</code></p></pre>
<p>But <code>Number</code> values will no longer be moved:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> n = <i>Number</i> { <i>odd</i>: <i>true</i>, <i>value</i>: <i>51</i> }<i>;</i>
    <i>let</i> m = n<i>;</i> <i>// `m` is a copy of `n`</i>
    <i>let</i> o = n<i>;</i> <i>// same. `n` is neither moved nor borrowed.</i>
}
</code></p></pre>
<p>Some traits are so common, they can be implemented automatically
by using the <code>derive</code> attribute:</p>
<pre><p>Rust code</p><p><code><i>#<i>[</i>derive<i>(</i>Clone, Copy<i>)</i><i>]</i></i>
<i>struct</i> <i>Number</i> {
    <i>odd</i>: <i>bool</i>,
    <i>value</i>: <i>i32</i>,
}

<i>// this expands to `impl Clone for Number` and `impl Copy for Number` blocks.</i>
</code></p></pre>
<p>Functions can be generic:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>foobar</i><i>&lt;</i><i>T</i><i>&gt;</i><i>(</i><i>arg</i>: <i>T</i><i>)</i> {
    <i>// do something with `arg`</i>
}
</code></p></pre>
<p>They can have multiple <em>type parameters</em>, which can then be used in the
function&#39;s declaration and its body, instead of concrete types:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>foobar</i><i>&lt;</i><i>L</i>, <i>R</i><i>&gt;</i><i>(</i><i>left</i>: <i>L</i>, <i>right</i>: <i>R</i><i>)</i> {
    <i>// do something with `left` and `right`</i>
}
</code></p></pre>
<p>Type parameters usually have <em>constraints</em>, so you can actually
do something with them.</p>
<p>The simplest constraints are just trait names:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>print</i><i>&lt;</i><i>T</i>: <i>Display</i><i>&gt;</i><i>(</i><i>value</i>: <i>T</i><i>)</i> {
    <i>println</i><i>!</i><i>(</i><i>&#34;value = {}&#34;</i>, value<i>)</i><i>;</i>
}

<i>fn</i> <i>print</i><i>&lt;</i><i>T</i>: <i>Debug</i><i>&gt;</i><i>(</i><i>value</i>: <i>T</i><i>)</i> {
    <i>println</i><i>!</i><i>(</i><i>&#34;value = {:?}&#34;</i>, value<i>)</i><i>;</i>
}
</code></p></pre>
<p>There&#39;s a longer syntax for type parameter constraints:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>print</i><i>&lt;</i><i>T</i><i>&gt;</i><i>(</i><i>value</i>: <i>T</i><i>)</i>
<i>where</i>
    <i>T</i>: <i>Display</i>,
{
    <i>println</i><i>!</i><i>(</i><i>&#34;value = {}&#34;</i>, value<i>)</i><i>;</i>
}
</code></p></pre>
<p>Constraints can be more complicated: they can require a type parameter
to implement multiple traits:</p>
<pre><p>Rust code</p><p><code><i>use</i> std<i>::</i>fmt<i>::</i>Debug<i>;</i>

<i>fn</i> <i>compare</i><i>&lt;</i><i>T</i><i>&gt;</i><i>(</i><i>left</i>: <i>T</i>, <i>right</i>: <i>T</i><i>)</i>
<i>where</i>
    <i>T</i>: <i>Debug</i> + <i>PartialEq</i>,
{
    <i>println</i><i>!</i><i>(</i><i>&#34;{:?} {} {:?}&#34;</i>, left, <i>if</i> left == right { <i>&#34;==&#34;</i> } else { <i>&#34;!=&#34;</i> }, right<i>)</i><i>;</i>
}

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>compare</i><i>(</i><i>&#34;tea&#34;</i>, <i>&#34;coffee&#34;</i><i>)</i><i>;</i>
    <i>// prints: &#34;tea&#34; != &#34;coffee&#34;</i>
}
</code></p></pre>
<p>Generic functions can be thought of as namespaces, containing an infinity
of functions with different concrete types.</p>
<p>Same as with crates, and modules, and types, generic functions can be &#34;explored&#34;
(navigated?) using <code>::</code></p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>use</i> std<i>::</i>any<i>::</i>type_name<i>;</i>
    <i>println</i><i>!</i><i>(</i><i>&#34;{}&#34;</i>, type_name::&lt;<i>i32</i>&gt;<i>(</i><i>)</i><i>)</i><i>;</i> <i>// prints &#34;i32&#34;</i>
    <i>println</i><i>!</i><i>(</i><i>&#34;{}&#34;</i>, type_name::&lt;<i>(</i><i>f64</i>, <i>char</i><i>)</i>&gt;<i>(</i><i>)</i><i>)</i><i>;</i> <i>// prints &#34;(f64, char)&#34;</i>
}
</code></p></pre>
<p>This is lovingly called <a href="https://turbo.fish/">turbofish syntax</a>, because
<code>::&lt;&gt;</code> looks like a fish.</p>
<p>Structs can be generic too:</p>
<pre><p>Rust code</p><p><code><i>struct</i> <i>Pair</i><i>&lt;</i><i>T</i><i>&gt;</i> {
    <i>a</i>: <i>T</i>,
    <i>b</i>: <i>T</i>,
}

<i>fn</i> <i>print_type_name</i><i>&lt;</i><i>T</i><i>&gt;</i><i>(</i><i>_val</i>: <i>&amp;</i><i>T</i><i>)</i> {
    <i>println</i><i>!</i><i>(</i><i>&#34;{}&#34;</i>, std::any::type_name::&lt;T&gt;<i>(</i><i>)</i><i>)</i><i>;</i>
}

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> p1 = <i>Pair</i> { <i>a</i>: <i>3</i>, <i>b</i>: <i>9</i> }<i>;</i>
    <i>let</i> p2 = <i>Pair</i> { <i>a</i>: <i>true</i>, <i>b</i>: <i>false</i> }<i>;</i>
    <i>print_type_name</i><i>(</i><i>&amp;</i>p1<i>)</i><i>;</i> <i>// prints &#34;Pair&lt;i32&gt;&#34;</i>
    <i>print_type_name</i><i>(</i><i>&amp;</i>p2<i>)</i><i>;</i> <i>// prints &#34;Pair&lt;bool&gt;&#34;</i>
}
</code></p></pre>
<p>The standard library type <code>Vec</code> (~ a heap-allocated array), is generic:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> <i>mut</i> v1 = <i>Vec</i><i>::</i><i>new</i><i>(</i><i>)</i><i>;</i>
    v1<i>.</i><i>push</i><i>(</i><i>1</i><i>)</i><i>;</i>
    <i>let</i> <i>mut</i> v2 = <i>Vec</i><i>::</i><i>new</i><i>(</i><i>)</i><i>;</i>
    v2<i>.</i><i>push</i><i>(</i><i>false</i><i>)</i><i>;</i>
    <i>print_type_name</i><i>(</i><i>&amp;</i>v1<i>)</i><i>;</i> <i>// prints &#34;Vec&lt;i32&gt;&#34;</i>
    <i>print_type_name</i><i>(</i><i>&amp;</i>v2<i>)</i><i>;</i> <i>// prints &#34;Vec&lt;bool&gt;&#34;</i>
}
</code></p></pre>
<p>Speaking of <code>Vec</code>, it comes with a macro that gives more or less &#34;vec literals&#34;:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> v1 = <i>vec</i><i>!</i><i>[</i><i>1</i>, <i>2</i>, <i>3</i><i>]</i><i>;</i>
    <i>let</i> v2 = <i>vec</i><i>!</i><i>[</i><i>true</i>, <i>false</i>, <i>true</i><i>]</i><i>;</i>
    <i>print_type_name</i><i>(</i><i>&amp;</i>v1<i>)</i><i>;</i> <i>// prints &#34;Vec&lt;i32&gt;&#34;</i>
    <i>print_type_name</i><i>(</i><i>&amp;</i>v2<i>)</i><i>;</i> <i>// prints &#34;Vec&lt;bool&gt;&#34;</i>
}
</code></p></pre>
<p>All of <code>name!()</code>, <code>name![]</code> or <code>name!{}</code> invoke a macro. Macros just expand to
regular code.</p>
<p>In fact, <code>println</code> is a macro:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>println</i><i>!</i><i>(</i><i>&#34;{}&#34;</i>, <i>&#34;Hello there!&#34;</i><i>)</i><i>;</i>
}
</code></p></pre>
<p>This expands to something that has the same effect as:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>use</i> std<i>::</i>io<i>::</i>{<i>self</i>, Write}<i>;</i>
    io<i>::</i><i>stdout</i><i>(</i><i>)</i><i>.</i><i>lock</i><i>(</i><i>)</i><i>.</i><i>write_all</i><i>(</i><i>b&#34;Hello there!\n&#34;</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
}
</code></p></pre>
<p><code>panic</code> is also a macro. It violently stops execution with an error
message, and the file name / line number of the error, if enabled:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>panic</i><i>!</i><i>(</i><i>&#34;This panics&#34;</i><i>)</i><i>;</i>
}
<i>// output: thread &#39;main&#39; panicked at &#39;This panics&#39;, src/main.rs:3:5</i>
</code></p></pre>
<p>Some methods also panic. For example, the <code>Option</code> type can contain something,
or it can contain nothing. If <code>.unwrap()</code> is called on it, and it contains
nothing, it panics:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> o1: <i>Option</i><i>&lt;</i><i>i32</i><i>&gt;</i> = Some<i>(</i><i>128</i><i>)</i><i>;</i>
    o1<i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i> <i>// this is fine</i>

    <i>let</i> o2: <i>Option</i><i>&lt;</i><i>i32</i><i>&gt;</i> = None<i>;</i>
    o2<i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i> <i>// this panics!</i>
}

<i>// output: thread &#39;main&#39; panicked at &#39;called `Option::unwrap()` on a `None` value&#39;, src/libcore/option.rs:378:21</i>
</code></p></pre>
<p><code>Option</code> is not a struct - it&#39;s an <code>enum</code>, with two variants.</p>
<pre><p>Rust code</p><p><code><i>enum</i> <i>Option</i><i>&lt;</i><i>T</i><i>&gt;</i> {
    None,
    Some<i>(</i><i>T</i><i>)</i>,
}

<i>impl</i><i>&lt;</i><i>T</i><i>&gt;</i> <i>Option</i><i>&lt;</i><i>T</i><i>&gt;</i> {
    <i>fn</i> <i>unwrap</i><i>(</i><i>self</i><i>)</i> -&gt; <i>T</i> {
        <i>// enums variants can be used in patterns:</i>
        <i>match</i> <i>self</i> {
            <i>Self</i><i>::</i>Some<i>(</i>t<i>)</i> =&gt; t,
            <i>Self</i><i>::</i>None =&gt; <i>panic</i><i>!</i><i>(</i><i>&#34;.unwrap() called on a None option&#34;</i><i>)</i>,
        }
    }
}

<i>use</i> <i>self</i><i>::</i>Option<i>::</i>{None, Some}<i>;</i>

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> o1: <i>Option</i><i>&lt;</i><i>i32</i><i>&gt;</i> = Some<i>(</i><i>128</i><i>)</i><i>;</i>
    o1<i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i> <i>// this is fine</i>

    <i>let</i> o2: <i>Option</i><i>&lt;</i><i>i32</i><i>&gt;</i> = None<i>;</i>
    o2<i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i> <i>// this panics!</i>
}

<i>// output: thread &#39;main&#39; panicked at &#39;.unwrap() called on a None option&#39;, src/main.rs:11:27</i>
</code></p></pre>
<p><code>Result</code> is also an enum, it can either contain something, or an error:</p>
<pre><p>Rust code</p><p><code><i>enum</i> <i>Result</i><i>&lt;</i><i>T</i>, <i>E</i><i>&gt;</i> {
    Ok<i>(</i><i>T</i><i>)</i>,
    Err<i>(</i><i>E</i><i>)</i>,
}
</code></p></pre>
<p>It also panics when unwrapped and containing an error.</p>
<p>Variables bindings have a &#34;lifetime&#34;:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>// `x` doesn&#39;t exist yet</i>
    {
        <i>let</i> x = <i>42</i><i>;</i> <i>// `x` starts existing</i>
        <i>println</i><i>!</i><i>(</i><i>&#34;x = {}&#34;</i>, x<i>)</i><i>;</i>
        <i>// `x` stops existing</i>
    }
    <i>// `x` no longer exists</i>
}
</code></p></pre>
<p>Similarly, references have a lifetime:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>// `x` doesn&#39;t exist yet</i>
    {
        <i>let</i> x = <i>42</i><i>;</i> <i>// `x` starts existing</i>
        <i>let</i> x_ref = <i>&amp;</i>x<i>;</i> <i>// `x_ref` starts existing - it borrows `x`</i>
        <i>println</i><i>!</i><i>(</i><i>&#34;x_ref = {}&#34;</i>, x_ref<i>)</i><i>;</i>
        <i>// `x_ref` stops existing</i>
        <i>// `x` stops existing</i>
    }
    <i>// `x` no longer exists</i>
}
</code></p></pre>
<p>The lifetime of a reference cannot exceed the lifetime of the variable
binding it borrows:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> x_ref = {
        <i>let</i> x = <i>42</i><i>;</i>
        <i>&amp;</i>x
    }<i>;</i>
    <i>println</i><i>!</i><i>(</i><i>&#34;x_ref = {}&#34;</i>, x_ref<i>)</i><i>;</i>
    <i>// error: `x` does not live long enough</i>
}
</code></p></pre>
<p>A variable binding can be immutably borrowed multiple times:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> x = <i>42</i><i>;</i>
    <i>let</i> x_ref1 = <i>&amp;</i>x<i>;</i>
    <i>let</i> x_ref2 = <i>&amp;</i>x<i>;</i>
    <i>let</i> x_ref3 = <i>&amp;</i>x<i>;</i>
    <i>println</i><i>!</i><i>(</i><i>&#34;{} {} {}&#34;</i>, x_ref1, x_ref2, x_ref3<i>)</i><i>;</i>
}
</code></p></pre>
<p>While borrowed, a variable binding cannot be mutated:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> <i>mut</i> x = <i>42</i><i>;</i>
    <i>let</i> x_ref = <i>&amp;</i>x<i>;</i>
    x = <i>13</i><i>;</i>
    <i>println</i><i>!</i><i>(</i><i>&#34;x_ref = {}&#34;</i>, x_ref<i>)</i><i>;</i>
    <i>// error: cannot assign to `x` because it is borrowed</i>
}
</code></p></pre>
<p>While immutably borrowed, a variable cannot be <em>mutably borrowed</em>:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> <i>mut</i> x = <i>42</i><i>;</i>
    <i>let</i> x_ref1 = <i>&amp;</i>x<i>;</i>
    <i>let</i> x_ref2 = <i>&amp;</i><i>mut</i> x<i>;</i>
    <i>// error: cannot borrow `x` as mutable because it is also borrowed as immutable</i>
    <i>println</i><i>!</i><i>(</i><i>&#34;x_ref1 = {}&#34;</i>, x_ref1<i>)</i><i>;</i>
}
</code></p></pre>
<p>References in function arguments also have lifetimes:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>print</i><i>(</i><i>x</i>: <i>&amp;</i><i>i32</i><i>)</i> {
    <i>// `x` is borrowed (from the outside) for the</i>
    <i>// entire time this function is called.</i>
}
</code></p></pre>
<p>Functions with reference arguments can be called with borrows
that have different lifetimes, so:</p>
<ul>
<li>All functions that take references are generic</li>
<li>Lifetimes are generic parameters</li>
</ul>
<p>Lifetimes&#39; names start with a single quote, <code>&#39;</code>:</p>
<pre><p>Rust code</p><p><code><i>// elided (non-named) lifetimes:</i>
<i>fn</i> <i>print</i><i>(</i><i>x</i>: <i>&amp;</i><i>i32</i><i>)</i> {}

<i>// named lifetimes:</i>
<i>fn</i> <i>print</i><i>&lt;</i><i>&#39;</i><i>a</i><i>&gt;</i><i>(</i><i>x</i>: <i>&amp;</i><i>&#39;</i><i>a</i> <i>i32</i><i>)</i> {}
</code></p></pre>
<p>This allows returning references whose lifetime depend on the
lifetime of the arguments:</p>
<pre><p>Rust code</p><p><code><i>struct</i> <i>Number</i> {
    <i>value</i>: <i>i32</i>,
}

<i>fn</i> <i>number_value</i><i>&lt;</i><i>&#39;</i><i>a</i><i>&gt;</i><i>(</i><i>num</i>: <i>&amp;</i><i>&#39;</i><i>a</i> <i>Number</i><i>)</i> -&gt; <i>&amp;</i><i>&#39;</i><i>a</i> <i>i32</i> {
    <i>&amp;</i>num<i>.</i><i>value</i>
}

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> n = <i>Number</i> { <i>value</i>: <i>47</i> }<i>;</i>
    <i>let</i> v = <i>number_value</i><i>(</i><i>&amp;</i>n<i>)</i><i>;</i>
    <i>// `v` borrows `n` (immutably), thus: `v` cannot outlive `n`.</i>
    <i>// While `v` exists, `n` cannot be mutably borrowed, mutated, moved, etc.</i>
}
</code></p></pre>
<p>When there is a <em>single</em> input lifetime, it doesn&#39;t need to be named,
and everything has the same lifetime, so the two functions below are
equivalent:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>number_value</i><i>&lt;</i><i>&#39;</i><i>a</i><i>&gt;</i><i>(</i><i>num</i>: <i>&amp;</i><i>&#39;</i><i>a</i> <i>Number</i><i>)</i> -&gt; <i>&amp;</i><i>&#39;</i><i>a</i> <i>i32</i> {
    <i>&amp;</i>num<i>.</i><i>value</i>
}

<i>fn</i> <i>number_value</i><i>(</i><i>num</i>: <i>&amp;</i><i>Number</i><i>)</i> -&gt; <i>&amp;</i><i>i32</i> {
    <i>&amp;</i>num<i>.</i><i>value</i>
}
</code></p></pre>
<p>Structs can also be <em>generic over lifetimes</em>, which allows them to
hold references:</p>
<pre><p>Rust code</p><p><code><i>struct</i> <i>NumRef</i><i>&lt;</i><i>&#39;</i><i>a</i><i>&gt;</i> {
    <i>x</i>: <i>&amp;</i><i>&#39;</i><i>a</i> <i>i32</i>,
}

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> x: <i>i32</i> = <i>99</i><i>;</i>
    <i>let</i> x_ref = <i>NumRef</i> { <i>x</i>: <i>&amp;</i>x }<i>;</i>
    <i>// `x_ref` cannot outlive `x`, etc.</i>
}
</code></p></pre>
<p>The same code, but with an additional function:</p>
<pre><p>Rust code</p><p><code><i>struct</i> <i>NumRef</i><i>&lt;</i><i>&#39;</i><i>a</i><i>&gt;</i> {
    <i>x</i>: <i>&amp;</i><i>&#39;</i><i>a</i> <i>i32</i>,
}

<i>fn</i> <i>as_num_ref</i><i>&lt;</i><i>&#39;</i><i>a</i><i>&gt;</i><i>(</i><i>x</i>: <i>&amp;</i><i>&#39;</i><i>a</i> <i>i32</i><i>)</i> -&gt; <i>NumRef</i><i>&lt;</i><i>&#39;</i><i>a</i><i>&gt;</i> {
    <i>NumRef</i> { <i>x</i>: <i>&amp;</i>x }
}

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> x: <i>i32</i> = <i>99</i><i>;</i>
    <i>let</i> x_ref = <i>as_num_ref</i><i>(</i><i>&amp;</i>x<i>)</i><i>;</i>
    <i>// `x_ref` cannot outlive `x`, etc.</i>
}
</code></p></pre>
<p>The same code, but with &#34;elided&#34; lifetimes:</p>
<pre><p>Rust code</p><p><code><i>struct</i> <i>NumRef</i><i>&lt;</i><i>&#39;</i><i>a</i><i>&gt;</i> {
    <i>x</i>: <i>&amp;</i><i>&#39;</i><i>a</i> <i>i32</i>,
}

<i>fn</i> <i>as_num_ref</i><i>(</i><i>x</i>: <i>&amp;</i><i>i32</i><i>)</i> -&gt; <i>NumRef</i><i>&lt;</i><i>&#39;</i><i>_</i><i>&gt;</i> {
    <i>NumRef</i> { <i>x</i>: <i>&amp;</i>x }
}

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> x: <i>i32</i> = <i>99</i><i>;</i>
    <i>let</i> x_ref = <i>as_num_ref</i><i>(</i><i>&amp;</i>x<i>)</i><i>;</i>
    <i>// `x_ref` cannot outlive `x`, etc.</i>
}
</code></p></pre>
<p><code>impl</code> blocks can be generic over lifetimes too:</p>
<pre><p>Rust code</p><p><code><i>impl</i><i>&lt;</i><i>&#39;</i><i>a</i><i>&gt;</i> <i>NumRef</i><i>&lt;</i><i>&#39;</i><i>a</i><i>&gt;</i> {
    <i>fn</i> <i>as_i32_ref</i><i>(</i><i>&amp;</i><i>&#39;</i><i>a</i> <i>self</i><i>)</i> -&gt; <i>&amp;</i><i>&#39;</i><i>a</i> <i>i32</i> {
        <i>self</i><i>.</i><i>x</i>
    }
}

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> x: <i>i32</i> = <i>99</i><i>;</i>
    <i>let</i> x_num_ref = <i>NumRef</i> { <i>x</i>: <i>&amp;</i>x }<i>;</i>
    <i>let</i> x_i32_ref = x_num_ref<i>.</i><i>as_i32_ref</i><i>(</i><i>)</i><i>;</i>
    <i>// neither ref can outlive `x`</i>
}
</code></p></pre>
<p>But you can do elision (&#34;to elide&#34;) there too:</p>
<pre><p>Rust code</p><p><code><i>impl</i><i>&lt;</i><i>&#39;</i><i>a</i><i>&gt;</i> <i>NumRef</i><i>&lt;</i><i>&#39;</i><i>a</i><i>&gt;</i> {
    <i>fn</i> <i>as_i32_ref</i><i>(</i><i>&amp;</i><i>self</i><i>)</i> -&gt; <i>&amp;</i><i>i32</i> {
        <i>self</i><i>.</i><i>x</i>
    }
}
</code></p></pre>
<p>You can elide even harder, if you never need the name:</p>
<pre><p>Rust code</p><p><code><i>impl</i> <i>NumRef</i><i>&lt;</i><i>&#39;</i><i>_</i><i>&gt;</i> {
    <i>fn</i> <i>as_i32_ref</i><i>(</i><i>&amp;</i><i>self</i><i>)</i> -&gt; <i>&amp;</i><i>i32</i> {
        <i>self</i><i>.</i><i>x</i>
    }
}
</code></p></pre>
<p>There is a special lifetime, named <code>&#39;static</code>, which is valid for the
entire program&#39;s lifetime.</p>
<p>String literals are <code>&#39;static</code>:</p>
<pre><p>Rust code</p><p><code><i>struct</i> <i>Person</i> {
    <i>name</i>: <i>&amp;</i><i>&#39;</i><i>static</i> <i>str</i>,
}

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> p = <i>Person</i> {
        <i>name</i>: <i>&#34;fasterthanlime&#34;</i>,
    }<i>;</i>
}
</code></p></pre>
<p>But <em>owned strings</em> are not static:</p>
<pre><p>Rust code</p><p><code><i>struct</i> <i>Person</i> {
    <i>name</i>: <i>&amp;</i><i>&#39;</i><i>static</i> <i>str</i>,
}

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> name = <i>format</i><i>!</i><i>(</i><i>&#34;fasterthan{}&#34;</i>, <i>&#34;lime&#34;</i><i>)</i><i>;</i>
    <i>let</i> p = <i>Person</i> { <i>name</i>: <i>&amp;</i>name }<i>;</i>
    <i>// error: `name` does not live long enough</i>
}
</code></p></pre>
<p>In that last example, the local <code>name</code> is not a <code>&amp;&#39;static str</code>, it&#39;s a
<code>String</code>. It&#39;s been allocated dynamically, and it will be freed. Its lifetime
is <em>less</em> than the whole program (even though it happens to be in <code>main</code>).</p>
<p>To store a non-<code>&#39;static</code> string in <code>Person</code>, it needs to either:</p>
<p>A) Be generic over a lifetime:</p>
<pre><p>Rust code</p><p><code><i>struct</i> <i>Person</i><i>&lt;</i><i>&#39;</i><i>a</i><i>&gt;</i> {
    <i>name</i>: <i>&amp;</i><i>&#39;</i><i>a</i> <i>str</i>,
}

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> name = <i>format</i><i>!</i><i>(</i><i>&#34;fasterthan{}&#34;</i>, <i>&#34;lime&#34;</i><i>)</i><i>;</i>
    <i>let</i> p = <i>Person</i> { <i>name</i>: <i>&amp;</i>name }<i>;</i>
    <i>// `p` cannot outlive `name`</i>
}
</code></p></pre>
<p>or</p>
<p>B) Take ownership of the string</p>
<pre><p>Rust code</p><p><code><i>struct</i> <i>Person</i> {
    <i>name</i>: <i>String</i>,
}

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> name = <i>format</i><i>!</i><i>(</i><i>&#34;fasterthan{}&#34;</i>, <i>&#34;lime&#34;</i><i>)</i><i>;</i>
    <i>let</i> p = <i>Person</i> { <i>name</i>: name }<i>;</i>
    <i>// `name` was moved into `p`, their lifetimes are no longer tied.</i>
}
</code></p></pre>
<p>Speaking of: in a struct literal, when a field is set to a variable binding of the
same name:</p>
<pre><p>Rust code</p><p><code>    <i>let</i> p = <i>Person</i> { <i>name</i>: name }<i>;</i>
</code></p></pre>
<p>It can be shortened like this:</p>
<pre><p>Rust code</p><p><code>    <i>let</i> p = <i>Person</i> { name }<i>;</i>
</code></p></pre>
<p>For many types in Rust, there are owned and non-owned variants:</p>
<ul>
<li>Strings: <code>String</code> is owned, <code>&amp;str</code> is a reference</li>
<li>Paths: <code>PathBuf</code> is owned, <code>&amp;Path</code> is a reference</li>
<li>Collections: <code>Vec&lt;T&gt;</code> is owned, <code>&amp;[T]</code> is a reference</li>
</ul>
<p>Rust has slices - they&#39;re a reference to multiple contiguous elements.</p>
<p>You can borrow a slice of a vector, for example:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> v = <i>vec</i><i>!</i><i>[</i><i>1</i>, <i>2</i>, <i>3</i>, <i>4</i>, <i>5</i><i>]</i><i>;</i>
    <i>let</i> v2 = <i>&amp;</i>v<i>[</i><i>2</i>..<i>4</i><i>]</i><i>;</i>
    <i>println</i><i>!</i><i>(</i><i>&#34;v2 = {:?}&#34;</i>, v2<i>)</i><i>;</i>
}

<i>// output:</i>
<i>// v2 = [3, 4]</i>
</code></p></pre>
<p>The above is not magical. The indexing operator (<code>foo[index]</code>) is
overloaded with the <code>Index</code> and <code>IndexMut</code> traits.</p>
<p>The <code>..</code> syntax is just range literals. Ranges are just a few
structs defined in the standard library.</p>
<p>They can be open-ended, and their rightmost bound can be inclusive,
if it&#39;s preceded by <code>=</code>.</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>// 0 or greater</i>
    <i>println</i><i>!</i><i>(</i><i>&#34;{:?}&#34;</i>, <i>(</i><i>0</i>..<i>)</i>.contains<i>(</i>&amp;<i>100</i><i>)</i><i>)</i><i>;</i> <i>// true</i>
    <i>// strictly less than 20</i>
    <i>println</i><i>!</i><i>(</i><i>&#34;{:?}&#34;</i>, <i>(</i>..<i>20</i><i>)</i>.contains<i>(</i>&amp;<i>20</i><i>)</i><i>)</i><i>;</i> <i>// false</i>
    <i>// 20 or less than 20</i>
    <i>println</i><i>!</i><i>(</i><i>&#34;{:?}&#34;</i>, <i>(</i>..=<i>20</i><i>)</i>.contains<i>(</i>&amp;<i>20</i><i>)</i><i>)</i><i>;</i> <i>// true</i>
    <i>// only 3, 4, 5</i>
    <i>println</i><i>!</i><i>(</i><i>&#34;{:?}&#34;</i>, <i>(</i><i>3</i>..<i>6</i><i>)</i>.contains<i>(</i>&amp;<i>4</i><i>)</i><i>)</i><i>;</i> <i>// true</i>
}
</code></p></pre>
<p>Borrowing rules apply to slices.</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>tail</i><i>(</i><i>s</i>: <i>&amp;</i><i>[</i><i>u8</i><i>]</i><i>)</i> -&gt; <i>&amp;</i><i>[</i><i>u8</i><i>]</i> {
  <i>&amp;</i>s<i>[</i><i>1</i>..<i>]</i> 
}

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> x = <i>&amp;</i><i>[</i><i>1</i>, <i>2</i>, <i>3</i>, <i>4</i>, <i>5</i><i>]</i><i>;</i>
    <i>let</i> y = <i>tail</i><i>(</i>x<i>)</i><i>;</i>
    <i>println</i><i>!</i><i>(</i><i>&#34;y = {:?}&#34;</i>, y<i>)</i><i>;</i>
}
</code></p></pre>
<p>This is the same as:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>tail</i><i>&lt;</i><i>&#39;</i><i>a</i><i>&gt;</i><i>(</i><i>s</i>: <i>&amp;</i><i>&#39;</i><i>a</i> <i>[</i><i>u8</i><i>]</i><i>)</i> -&gt; <i>&amp;</i><i>&#39;</i><i>a</i> <i>[</i><i>u8</i><i>]</i> {
  <i>&amp;</i>s<i>[</i><i>1</i>..<i>]</i> 
}
</code></p></pre>
<p>This is legal:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> y = {
        <i>let</i> x = <i>&amp;</i><i>[</i><i>1</i>, <i>2</i>, <i>3</i>, <i>4</i>, <i>5</i><i>]</i><i>;</i>
        <i>tail</i><i>(</i>x<i>)</i>
    }<i>;</i>
    <i>println</i><i>!</i><i>(</i><i>&#34;y = {:?}&#34;</i>, y<i>)</i><i>;</i>
}
</code></p></pre>
<p>...but only because <code>[1, 2, 3, 4, 5]</code> is a <code>&#39;static</code> array.</p>
<p>So, this is illegal:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> y = {
        <i>let</i> v = <i>vec</i><i>!</i><i>[</i><i>1</i>, <i>2</i>, <i>3</i>, <i>4</i>, <i>5</i><i>]</i><i>;</i>
        <i>tail</i><i>(</i><i>&amp;</i>v<i>)</i>
        <i>// error: `v` does not live long enough</i>
    }<i>;</i>
    <i>println</i><i>!</i><i>(</i><i>&#34;y = {:?}&#34;</i>, y<i>)</i><i>;</i>
}
</code></p></pre>
<p>...because a vector is heap-allocated, and it has a non-<code>&#39;static</code> lifetime.</p>
<p><code>&amp;str</code> values are really slices.</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>file_ext</i><i>(</i><i>name</i>: <i>&amp;</i><i>str</i><i>)</i> -&gt; <i>Option</i><i>&lt;</i><i>&amp;</i><i>str</i><i>&gt;</i> {
    <i>// this does not create a new string - it returns</i>
    <i>// a slice of the argument.</i>
    name<i>.</i><i>split</i><i>(</i><i>&#34;.&#34;</i><i>)</i><i>.</i><i>last</i><i>(</i><i>)</i>
}

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> name = <i>&#34;Read me. Or don&#39;t.txt&#34;</i><i>;</i>
    <i>if</i> <i>let</i> Some<i>(</i>ext<i>)</i> = <i>file_ext</i><i>(</i>name<i>)</i> {
        <i>println</i><i>!</i><i>(</i><i>&#34;file extension: {}&#34;</i>, ext<i>)</i><i>;</i>
    } <i>else</i> {
        <i>println</i><i>!</i><i>(</i><i>&#34;no file extension&#34;</i><i>)</i><i>;</i>
    }
}
</code></p></pre>
<p>...so the borrow rules apply here too:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> ext = {
        <i>let</i> name = <i>String</i><i>::</i><i>from</i><i>(</i><i>&#34;Read me. Or don&#39;t.txt&#34;</i><i>)</i><i>;</i>
        <i>file_ext</i><i>(</i><i>&amp;</i>name<i>)</i><i>.</i><i>unwrap_or</i><i>(</i><i>&#34;&#34;</i><i>)</i>
        <i>// error: `name` does not live long enough</i>
    }<i>;</i>
    <i>println</i><i>!</i><i>(</i><i>&#34;extension: {:?}&#34;</i>, ext<i>)</i><i>;</i>
}
</code></p></pre>
<p>Functions that can fail typically return a <code>Result</code>:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> s = std<i>::</i>str<i>::</i><i>from_utf8</i><i>(</i><i>&amp;</i><i>[</i><i>240</i>, <i>159</i>, <i>141</i>, <i>137</i><i>]</i><i>)</i><i>;</i>
    <i>println</i><i>!</i><i>(</i><i>&#34;{:?}&#34;</i>, s<i>)</i><i>;</i>
    <i>// prints: Ok(&#34;🍉&#34;)</i>

    <i>let</i> s = std<i>::</i>str<i>::</i><i>from_utf8</i><i>(</i><i>&amp;</i><i>[</i><i>195</i>, <i>40</i><i>]</i><i>)</i><i>;</i>
    <i>println</i><i>!</i><i>(</i><i>&#34;{:?}&#34;</i>, s<i>)</i><i>;</i>
    <i>// prints: Err(Utf8Error { valid_up_to: 0, error_len: Some(1) })</i>
}
</code></p></pre>
<p>If you want to panic in case of failure, you can <code>.unwrap()</code>:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> s = std<i>::</i>str<i>::</i><i>from_utf8</i><i>(</i><i>&amp;</i><i>[</i><i>240</i>, <i>159</i>, <i>141</i>, <i>137</i><i>]</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
    <i>println</i><i>!</i><i>(</i><i>&#34;{:?}&#34;</i>, s<i>)</i><i>;</i>
    <i>// prints: &#34;🍉&#34;</i>

    <i>let</i> s = std<i>::</i>str<i>::</i><i>from_utf8</i><i>(</i><i>&amp;</i><i>[</i><i>195</i>, <i>40</i><i>]</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
    <i>// prints: thread &#39;main&#39; panicked at &#39;called `Result::unwrap()`</i>
    <i>// on an `Err` value: Utf8Error { valid_up_to: 0, error_len: Some(1) }&#39;,</i>
    <i>// src/libcore/result.rs:1165:5</i>
}
</code></p></pre>
<p>Or <code>.expect()</code>, for a custom message:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> s = std<i>::</i>str<i>::</i><i>from_utf8</i><i>(</i><i>&amp;</i><i>[</i><i>195</i>, <i>40</i><i>]</i><i>)</i><i>.</i><i>expect</i><i>(</i><i>&#34;valid utf-8&#34;</i><i>)</i><i>;</i>
    <i>// prints: thread &#39;main&#39; panicked at &#39;valid utf-8: Utf8Error</i>
    <i>// { valid_up_to: 0, error_len: Some(1) }&#39;, src/libcore/result.rs:1165:5</i>
}
</code></p></pre>
<p>Or, you can <code>match</code>:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>match</i> std<i>::</i>str<i>::</i><i>from_utf8</i><i>(</i><i>&amp;</i><i>[</i><i>240</i>, <i>159</i>, <i>141</i>, <i>137</i><i>]</i><i>)</i> {
        Ok<i>(</i>s<i>)</i> =&gt; <i>println</i><i>!</i><i>(</i><i>&#34;{}&#34;</i>, s<i>)</i>,
        Err<i>(</i>e<i>)</i> =&gt; <i>panic</i><i>!</i><i>(</i>e<i>)</i>,
    }
    <i>// prints 🍉</i>
}
</code></p></pre>
<p>Or you can <code>if let</code>:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>if</i> <i>let</i> Ok<i>(</i>s<i>)</i> = std<i>::</i>str<i>::</i><i>from_utf8</i><i>(</i><i>&amp;</i><i>[</i><i>240</i>, <i>159</i>, <i>141</i>, <i>137</i><i>]</i><i>)</i> {
        <i>println</i><i>!</i><i>(</i><i>&#34;{}&#34;</i>, s<i>)</i><i>;</i>
    }
    <i>// prints 🍉</i>
}
</code></p></pre>
<p>Or you can bubble up the error:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> -&gt; <i>Result</i><i>&lt;</i><i>(</i><i>)</i>, std<i>::</i>str<i>::</i><i>Utf8Error</i><i>&gt;</i> {
    <i>match</i> std<i>::</i>str<i>::</i><i>from_utf8</i><i>(</i><i>&amp;</i><i>[</i><i>240</i>, <i>159</i>, <i>141</i>, <i>137</i><i>]</i><i>)</i> {
        Ok<i>(</i>s<i>)</i> =&gt; <i>println</i><i>!</i><i>(</i><i>&#34;{}&#34;</i>, s<i>)</i>,
        Err<i>(</i>e<i>)</i> =&gt; <i>return</i> Err<i>(</i>e<i>)</i>,
    }
    Ok<i>(</i><i>(</i><i>)</i><i>)</i>
}
</code></p></pre>
<p>Or you can use <code>?</code> to do it the concise way:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> -&gt; <i>Result</i><i>&lt;</i><i>(</i><i>)</i>, std<i>::</i>str<i>::</i><i>Utf8Error</i><i>&gt;</i> {
    <i>let</i> s = std<i>::</i>str<i>::</i><i>from_utf8</i><i>(</i><i>&amp;</i><i>[</i><i>240</i>, <i>159</i>, <i>141</i>, <i>137</i><i>]</i><i>)</i>?<i>;</i>
    <i>println</i><i>!</i><i>(</i><i>&#34;{}&#34;</i>, s<i>)</i><i>;</i>
    Ok<i>(</i><i>(</i><i>)</i><i>)</i>
}
</code></p></pre>
<p>The <code>*</code> operator can be used to <em>dereference</em>, but you don&#39;t need to do
that to access fields or call methods:</p>
<pre><p>Rust code</p><p><code><i>struct</i> <i>Point</i> {
    <i>x</i>: <i>f64</i>,
    <i>y</i>: <i>f64</i>,
}

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> p = <i>Point</i> { <i>x</i>: <i>1.0</i>, <i>y</i>: <i>3.0</i> }<i>;</i>
    <i>let</i> p_ref = <i>&amp;</i>p<i>;</i>
    <i>println</i><i>!</i><i>(</i><i>&#34;({}, {})&#34;</i>, p_ref.x, p_ref.y<i>)</i><i>;</i>
}

<i>// prints `(1, 3)`</i>
</code></p></pre>
<p>And you can only do it if the type is <code>Copy</code>:</p>
<pre><p>Rust code</p><p><code><i>struct</i> <i>Point</i> {
    <i>x</i>: <i>f64</i>,
    <i>y</i>: <i>f64</i>,
}

<i>fn</i> <i>negate</i><i>(</i><i>p</i>: <i>Point</i><i>)</i> -&gt; <i>Point</i> {
    <i>Point</i> {
        <i>x</i>: -p<i>.</i><i>x</i>,
        <i>y</i>: -p<i>.</i><i>y</i>,
    }
}

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> p = <i>Point</i> { <i>x</i>: <i>1.0</i>, <i>y</i>: <i>3.0</i> }<i>;</i>
    <i>let</i> p_ref = <i>&amp;</i>p<i>;</i>
    <i>negate</i><i>(</i><i>*</i>p_ref<i>)</i><i>;</i>
    <i>// error: cannot move out of `*p_ref` which is behind a shared reference</i>
}
</code></p></pre><pre><p>Rust code</p><p><code><i>// now `Point` is `Copy`</i>
<i>#<i>[</i>derive<i>(</i>Clone, Copy<i>)</i><i>]</i></i>
<i>struct</i> <i>Point</i> {
    <i>x</i>: <i>f64</i>,
    <i>y</i>: <i>f64</i>,
}

<i>fn</i> <i>negate</i><i>(</i><i>p</i>: <i>Point</i><i>)</i> -&gt; <i>Point</i> {
    <i>Point</i> {
        <i>x</i>: -p<i>.</i><i>x</i>,
        <i>y</i>: -p<i>.</i><i>y</i>,
    }
}

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> p = <i>Point</i> { <i>x</i>: <i>1.0</i>, <i>y</i>: <i>3.0</i> }<i>;</i>
    <i>let</i> p_ref = <i>&amp;</i>p<i>;</i>
    <i>negate</i><i>(</i><i>*</i>p_ref<i>)</i><i>;</i> <i>// ...and now this works</i>
}
</code></p></pre>
<p>Closures are just functions of type <code>Fn</code>, <code>FnMut</code> or <code>FnOnce</code> with some captured context.</p>
<p>Their parameters are a comma-separated list of names within a pair of pipes
(<code>|</code>). They don&#39;t <em>need</em> curly braces, unless you want to have multiple statements.</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>for_each_planet</i><i>&lt;</i><i>F</i><i>&gt;</i><i>(</i><i>f</i>: <i>F</i><i>)</i>
    <i>where</i> <i>F</i>: <i>Fn</i><i>(</i><i>&amp;</i><i>&#39;</i><i>static</i> <i>str</i><i>)</i>
{
    <i>f</i><i>(</i><i>&#34;Earth&#34;</i><i>)</i><i>;</i>
    <i>f</i><i>(</i><i>&#34;Mars&#34;</i><i>)</i><i>;</i>
    <i>f</i><i>(</i><i>&#34;Jupiter&#34;</i><i>)</i><i>;</i>
}
 
<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>for_each_planet</i><i>(</i>|planet| <i>println</i><i>!</i><i>(</i><i>&#34;Hello, {}&#34;</i>, planet<i>)</i><i>)</i><i>;</i>
}

<i>// prints:</i>
<i>// Hello, Earth</i>
<i>// Hello, Mars</i>
<i>// Hello, Jupiter</i>
</code></p></pre>
<p>The borrow rules apply to them too:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>for_each_planet</i><i>&lt;</i><i>F</i><i>&gt;</i><i>(</i><i>f</i>: <i>F</i><i>)</i>
    <i>where</i> <i>F</i>: <i>Fn</i><i>(</i><i>&amp;</i><i>&#39;</i><i>static</i> <i>str</i><i>)</i>
{
    <i>f</i><i>(</i><i>&#34;Earth&#34;</i><i>)</i><i>;</i>
    <i>f</i><i>(</i><i>&#34;Mars&#34;</i><i>)</i><i>;</i>
    <i>f</i><i>(</i><i>&#34;Jupiter&#34;</i><i>)</i><i>;</i>
}
 
<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> greeting = <i>String</i><i>::</i><i>from</i><i>(</i><i>&#34;Good to see you&#34;</i><i>)</i><i>;</i>
    <i>for_each_planet</i><i>(</i>|planet| <i>println</i><i>!</i><i>(</i><i>&#34;{}, {}&#34;</i>, greeting, planet<i>)</i><i>)</i><i>;</i>
    <i>// our closure borrows `greeting`, so it cannot outlive it</i>
}
</code></p></pre>
<p>For example, this would not work:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>for_each_planet</i><i>&lt;</i><i>F</i><i>&gt;</i><i>(</i><i>f</i>: <i>F</i><i>)</i>
    <i>where</i> <i>F</i>: <i>Fn</i><i>(</i><i>&amp;</i><i>&#39;</i><i>static</i> <i>str</i><i>)</i> + <i>&#39;</i><i>static</i> <i>// `F` must now have &#34;&#39;static&#34; lifetime</i>
{
    <i>f</i><i>(</i><i>&#34;Earth&#34;</i><i>)</i><i>;</i>
    <i>f</i><i>(</i><i>&#34;Mars&#34;</i><i>)</i><i>;</i>
    <i>f</i><i>(</i><i>&#34;Jupiter&#34;</i><i>)</i><i>;</i>
}

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> greeting = <i>String</i><i>::</i><i>from</i><i>(</i><i>&#34;Good to see you&#34;</i><i>)</i><i>;</i>
    <i>for_each_planet</i><i>(</i>|planet| <i>println</i><i>!</i><i>(</i><i>&#34;{}, {}&#34;</i>, greeting, planet<i>)</i><i>)</i><i>;</i>
    <i>// error: closure may outlive the current function, but it borrows</i>
    <i>// `greeting`, which is owned by the current function</i>
}
</code></p></pre>
<p>But this would:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> greeting = <i>String</i><i>::</i><i>from</i><i>(</i><i>&#34;You&#39;re doing great&#34;</i><i>)</i><i>;</i>
    <i>for_each_planet</i><i>(</i><i>move</i> |planet| <i>println</i><i>!</i><i>(</i><i>&#34;{}, {}&#34;</i>, greeting, planet<i>)</i><i>)</i><i>;</i>
    <i>// `greeting` is no longer borrowed, it is *moved* into</i>
    <i>// the closure.</i>
}
</code></p></pre>
<p>An <code>FnMut</code> needs to be mutably borrowed to be called, so it can
only be called once at a time.</p>
<p>This is legal:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>foobar</i><i>&lt;</i><i>F</i><i>&gt;</i><i>(</i><i>f</i>: <i>F</i><i>)</i>
    <i>where</i> <i>F</i>: <i>Fn</i><i>(</i><i>i32</i><i>)</i> -&gt; <i>i32</i>
{
    <i>println</i><i>!</i><i>(</i><i>&#34;{}&#34;</i>, f<i>(</i>f<i>(</i><i>2</i><i>)</i><i>)</i><i>)</i><i>;</i> 
}
 
<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>foobar</i><i>(</i>|x| x <i>*</i> <i>2</i><i>)</i><i>;</i>
}

<i>// output: 8</i>
</code></p></pre>
<p>This isn&#39;t:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>foobar</i><i>&lt;</i><i>F</i><i>&gt;</i><i>(</i><i>mut</i> <i>f</i>: <i>F</i><i>)</i>
    <i>where</i> <i>F</i>: <i>FnMut</i><i>(</i><i>i32</i><i>)</i> -&gt; <i>i32</i>
{
    <i>println</i><i>!</i><i>(</i><i>&#34;{}&#34;</i>, f<i>(</i>f<i>(</i><i>2</i><i>)</i><i>)</i><i>)</i><i>;</i> 
    <i>// error: cannot borrow `f` as mutable more than once at a time</i>
}
 
<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>foobar</i><i>(</i>|x| x <i>*</i> <i>2</i><i>)</i><i>;</i>
}
</code></p></pre>
<p>This is legal again:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>foobar</i><i>&lt;</i><i>F</i><i>&gt;</i><i>(</i><i>mut</i> <i>f</i>: <i>F</i><i>)</i>
    <i>where</i> <i>F</i>: <i>FnMut</i><i>(</i><i>i32</i><i>)</i> -&gt; <i>i32</i>
{
    <i>let</i> tmp = <i>f</i><i>(</i><i>2</i><i>)</i><i>;</i>
    <i>println</i><i>!</i><i>(</i><i>&#34;{}&#34;</i>, f<i>(</i>tmp<i>)</i><i>)</i><i>;</i> 
}
 
<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>foobar</i><i>(</i>|x| x <i>*</i> <i>2</i><i>)</i><i>;</i>
}

<i>// output: 8</i>
</code></p></pre>
<p><code>FnMut</code> exists because some closures <em>mutably borrow</em> local variables:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>foobar</i><i>&lt;</i><i>F</i><i>&gt;</i><i>(</i><i>mut</i> <i>f</i>: <i>F</i><i>)</i>
    <i>where</i> <i>F</i>: <i>FnMut</i><i>(</i><i>i32</i><i>)</i> -&gt; <i>i32</i>
{
    <i>let</i> tmp = <i>f</i><i>(</i><i>2</i><i>)</i><i>;</i>
    <i>println</i><i>!</i><i>(</i><i>&#34;{}&#34;</i>, f<i>(</i>tmp<i>)</i><i>)</i><i>;</i> 
}
 
<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> <i>mut</i> acc = <i>2</i><i>;</i>
    <i>foobar</i><i>(</i>|x| {
        acc += <i>1</i><i>;</i>
        x <i>*</i> acc
    }<i>)</i><i>;</i>
}

<i>// output: 24</i>
</code></p></pre>
<p>Those closures cannot be passed to functions expecting <code>Fn</code>:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>foobar</i><i>&lt;</i><i>F</i><i>&gt;</i><i>(</i><i>f</i>: <i>F</i><i>)</i>
    <i>where</i> <i>F</i>: <i>Fn</i><i>(</i><i>i32</i><i>)</i> -&gt; <i>i32</i>
{
    <i>println</i><i>!</i><i>(</i><i>&#34;{}&#34;</i>, f<i>(</i>f<i>(</i><i>2</i><i>)</i><i>)</i><i>)</i><i>;</i> 
}
 
<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> <i>mut</i> acc = <i>2</i><i>;</i>
    <i>foobar</i><i>(</i>|x| {
        acc += <i>1</i><i>;</i>
        <i>// error: cannot assign to `acc`, as it is a</i>
        <i>// captured variable in a `Fn` closure.</i>
        <i>// the compiler suggests &#34;changing foobar</i>
        <i>// to accept closures that implement `FnMut`&#34;</i>
        x <i>*</i> acc
    }<i>)</i><i>;</i>
}
</code></p></pre>
<p><code>FnOnce</code> closures can only be called once. They exist because some closure
move out variables that have been moved when captured:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>foobar</i><i>&lt;</i><i>F</i><i>&gt;</i><i>(</i><i>f</i>: <i>F</i><i>)</i>
    <i>where</i> <i>F</i>: <i>FnOnce</i><i>(</i><i>)</i> -&gt; <i>String</i>
{
    <i>println</i><i>!</i><i>(</i><i>&#34;{}&#34;</i>, f<i>(</i><i>)</i><i>)</i><i>;</i> 
}
 
<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> s = <i>String</i><i>::</i><i>from</i><i>(</i><i>&#34;alright&#34;</i><i>)</i><i>;</i>
    <i>foobar</i><i>(</i><i>move</i> || s<i>)</i><i>;</i>
    <i>// `s` was moved into our closure, and our</i>
    <i>// closures moves it to the caller by returning</i>
    <i>// it. Remember that `String` is not `Copy`.</i>
}
</code></p></pre>
<p>This is enforced naturally, as <code>FnOnce</code> closures need to be <em>moved</em>
in order to be called.</p>
<p>So, for example, this is illegal:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>foobar</i><i>&lt;</i><i>F</i><i>&gt;</i><i>(</i><i>f</i>: <i>F</i><i>)</i>
    <i>where</i> <i>F</i>: <i>FnOnce</i><i>(</i><i>)</i> -&gt; <i>String</i>
{
    <i>println</i><i>!</i><i>(</i><i>&#34;{}&#34;</i>, f<i>(</i><i>)</i><i>)</i><i>;</i> 
    <i>println</i><i>!</i><i>(</i><i>&#34;{}&#34;</i>, f<i>(</i><i>)</i><i>)</i><i>;</i> 
    <i>// error: use of moved value: `f`</i>
}
</code></p></pre>
<p>And, if you need convincing that our closure <em>does</em> move <code>s</code>,
this is illegal too:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> s = <i>String</i><i>::</i><i>from</i><i>(</i><i>&#34;alright&#34;</i><i>)</i><i>;</i>
    <i>foobar</i><i>(</i><i>move</i> || s<i>)</i><i>;</i>
    <i>foobar</i><i>(</i><i>move</i> || s<i>)</i><i>;</i>
    <i>// use of moved value: `s`</i>
}
</code></p></pre>
<p>But this is fine:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> s = <i>String</i><i>::</i><i>from</i><i>(</i><i>&#34;alright&#34;</i><i>)</i><i>;</i>
    <i>foobar</i><i>(</i>|| s<i>.</i><i>clone</i><i>(</i><i>)</i><i>)</i><i>;</i>
    <i>foobar</i><i>(</i>|| s<i>.</i><i>clone</i><i>(</i><i>)</i><i>)</i><i>;</i>
}
</code></p></pre>
<p>Here&#39;s a closure with two arguments:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>foobar</i><i>&lt;</i><i>F</i><i>&gt;</i><i>(</i><i>x</i>: <i>i32</i>, <i>y</i>: <i>i32</i>, <i>is_greater</i>: <i>F</i><i>)</i>
    <i>where</i> <i>F</i>: <i>Fn</i><i>(</i><i>i32</i>, <i>i32</i><i>)</i> -&gt; <i>bool</i>
{
    <i>let</i> <i>(</i>greater, smaller<i>)</i> = <i>if</i> <i>is_greater</i><i>(</i>x, y<i>)</i> {
        <i>(</i>x, y<i>)</i>
    } <i>else</i> {
        <i>(</i>y, x<i>)</i>
    }<i>;</i>
    <i>println</i><i>!</i><i>(</i><i>&#34;{} is greater than {}&#34;</i>, greater, smaller<i>)</i><i>;</i>
}
 
<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>foobar</i><i>(</i><i>32</i>, <i>64</i>, |x, y| x &gt; y<i>)</i><i>;</i>
}
</code></p></pre>
<p>Here&#39;s a closure ignoring both its arguments:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>foobar</i><i>(</i><i>32</i>, <i>64</i>, |_, _| <i>panic</i><i>!</i><i>(</i><i>&#34;Comparing is futile!&#34;</i><i>)</i><i>)</i><i>;</i>
}
</code></p></pre>
<p>Here&#39;s a slightly worrying closure:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>countdown</i><i>&lt;</i><i>F</i><i>&gt;</i><i>(</i><i>count</i>: <i>usize</i>, <i>tick</i>: <i>F</i><i>)</i>
    <i>where</i> <i>F</i>: <i>Fn</i><i>(</i><i>usize</i><i>)</i>
{
    <i>for</i> i <i>in</i> <i>(</i><i>1</i>..=count<i>)</i><i>.</i><i>rev</i><i>(</i><i>)</i> {
        <i>tick</i><i>(</i>i<i>)</i><i>;</i>
    }
}
 
<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>countdown</i><i>(</i><i>3</i>, |i| <i>println</i><i>!</i><i>(</i><i>&#34;tick {}...&#34;</i>, i<i>)</i><i>)</i><i>;</i>
}

<i>// output:</i>
<i>// tick 3...</i>
<i>// tick 2...</i>
<i>// tick 1...</i>
</code></p></pre>
<p>And here&#39;s a toilet closure:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>countdown</i><i>(</i><i>3</i>, |_| <i>(</i><i>)</i><i>)</i><i>;</i>
}
</code></p></pre>
<p>Called thusly because <code>|_| ()</code> looks like a toilet.</p>
<p>Anything that is iterable can be used in a <code>for in</code> loop.</p>
<p>We&#39;ve just seen a range being used, but it also works with a <code>Vec</code>:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>for</i> i <i>in</i> <i>vec</i><i>!</i><i>[</i><i>52</i>, <i>49</i>, <i>21</i><i>]</i> {
        <i>println</i><i>!</i><i>(</i><i>&#34;I like the number {}&#34;</i>, i<i>)</i><i>;</i>
    }
}
</code></p></pre>
<p>Or a slice:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>for</i> i <i>in</i> <i>&amp;</i><i>[</i><i>52</i>, <i>49</i>, <i>21</i><i>]</i> {
        <i>println</i><i>!</i><i>(</i><i>&#34;I like the number {}&#34;</i>, i<i>)</i><i>;</i>
    }
}

<i>// output:</i>
<i>// I like the number 52</i>
<i>// I like the number 49</i>
<i>// I like the number 21</i>
</code></p></pre>
<p>Or an actual iterator:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>// note: `&amp;str` also has a `.bytes()` iterator.</i>
    <i>// Rust&#39;s `char` type is a &#34;Unicode scalar value&#34;</i>
    <i>for</i> c <i>in</i> <i>&#34;rust&#34;</i><i>.</i><i>chars</i><i>(</i><i>)</i> {
        <i>println</i><i>!</i><i>(</i><i>&#34;Give me a {}&#34;</i>, c<i>)</i><i>;</i>
    }
}

<i>// output:</i>
<i>// Give me a r</i>
<i>// Give me a u</i>
<i>// Give me a s</i>
<i>// Give me a t</i>
</code></p></pre>
<p>Even if the iterator items are filtered and mapped and flattened:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>for</i> c <i>in</i> <i>&#34;SuRPRISE INbOUND&#34;</i>
        <i>.</i><i>chars</i><i>(</i><i>)</i>
        <i>.</i><i>filter</i><i>(</i>|c| c<i>.</i><i>is_lowercase</i><i>(</i><i>)</i><i>)</i>
        <i>.</i><i>flat_map</i><i>(</i>|c| c<i>.</i><i>to_uppercase</i><i>(</i><i>)</i><i>)</i>
    {
        <i>print</i><i>!</i><i>(</i><i>&#34;{}&#34;</i>, c<i>)</i><i>;</i>
    }
    <i>println</i><i>!</i><i>(</i><i>)</i><i>;</i>
}

<i>// output: UB</i>
</code></p></pre>
<p>You can return a closure from a function:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>make_tester</i><i>(</i><i>answer</i>: <i>String</i><i>)</i> -&gt; <i>impl</i> <i>Fn</i><i>(</i><i>&amp;</i><i>str</i><i>)</i> -&gt; <i>bool</i> {
    <i>move</i> |challenge| {
        challenge == answer
    }
}

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>// you can use `.into()` to perform conversions</i>
    <i>// between various types, here `&amp;&#39;static str` and `String`</i>
    <i>let</i> test = <i>make_tester</i><i>(</i><i>&#34;hunter2&#34;</i><i>.</i><i>into</i><i>(</i><i>)</i><i>)</i><i>;</i>
    <i>println</i><i>!</i><i>(</i><i>&#34;{}&#34;</i>, test<i>(</i><i>&#34;******&#34;</i><i>)</i><i>)</i><i>;</i>
    <i>println</i><i>!</i><i>(</i><i>&#34;{}&#34;</i>, test<i>(</i><i>&#34;hunter2&#34;</i><i>)</i><i>)</i><i>;</i>
}
</code></p></pre>
<p>You can even move a reference to some of a function&#39;s arguments,
into a closure it returns:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>make_tester</i><i>&lt;</i><i>&#39;</i><i>a</i><i>&gt;</i><i>(</i><i>answer</i>: <i>&amp;</i><i>&#39;</i><i>a</i> <i>str</i><i>)</i> -&gt; <i>impl</i> <i>Fn</i><i>(</i><i>&amp;</i><i>str</i><i>)</i> -&gt; <i>bool</i> + <i>&#39;</i><i>a</i> {
    <i>move</i> |challenge| {
        challenge == answer
    }
}

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> test = <i>make_tester</i><i>(</i><i>&#34;hunter2&#34;</i><i>)</i><i>;</i>
    <i>println</i><i>!</i><i>(</i><i>&#34;{}&#34;</i>, test<i>(</i><i>&#34;*******&#34;</i><i>)</i><i>)</i><i>;</i>
    <i>println</i><i>!</i><i>(</i><i>&#34;{}&#34;</i>, test<i>(</i><i>&#34;hunter2&#34;</i><i>)</i><i>)</i><i>;</i>
}

<i>// output:</i>
<i>// false</i>
<i>// true</i>
</code></p></pre>
<p>Or, with elided lifetimes:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>make_tester</i><i>(</i><i>answer</i>: <i>&amp;</i><i>str</i><i>)</i> -&gt; <i>impl</i> <i>Fn</i><i>(</i><i>&amp;</i><i>str</i><i>)</i> -&gt; <i>bool</i> + <i>&#39;</i><i>_</i> {
    <i>move</i> |challenge| {
        challenge == answer
    }
}
</code></p></pre>
<p>And with that, we hit the 30-minute estimated reading time mark, and you
should be able to read <em>most</em> of the Rust code you find online.</p>
<p>Writing Rust is a very different experience from reading Rust. On one hand,
you&#39;re not reading the <em>solution</em> to a problem, you&#39;re actually solving it.
On the other hand, the Rust compiler helps out a <em>lot</em>.</p>
<p>For all of the intentional mistakes made above (&#34;this code is illegal&#34;, etc.),
rustc always has very good error messages <em>and</em> insightful suggestions.</p>
<p>And when there&#39;s a hint missing, the compiler team is <a href="https://mobile.twitter.com/fasterthanlime/status/1219601989404954624">not afraid to add it</a>.</p>
<p>For more Rust material, you may want to check out:</p>
<ul>
<li><a href="https://doc.rust-lang.org/book/">The Rust Book</a></li>
<li><a href="https://doc.rust-lang.org/stable/rust-by-example/">Rust By Example</a></li>
<li><a href="https://readrust.net/">Read Rust</a></li>
<li><a href="https://this-week-in-rust.org/">This Week In Rust</a></li>
</ul>
<p>I also <a href="https://fasterthanli.me/tags/rust/">blog about Rust</a> and <a href="https://twitter.com/fasterthanlime">tweet about
Rust</a> a lot, so if you liked this
article, you know what to do.</p>
<p>Have fun!</p>

</div><div>
  
    
    
      <p>
    This article was made possible thanks to my patrons:
    Alexander Payne, Fredrik Østrem, David Barsky, Yufan Lou, Stephen Molyneaux,
Barret Rennie, Thomas Corbin, MW, Jacob Cheriathundam, Michael Watzko, Embark
Studios, Eugene Bulkin, Marcus Griep, Petar Radosevic, Tool Army, Tully,
Santiago Lema, Spencer Gilbert, Jörn Huxhorn, Garrett Ward, DEX, Christian
Oudard, Ronen Cohen, Thor Kamphefner, Kamran Khan, Cole Kurkowski, Arjen
Laarhoven, Vicente Bosch, Chirag Jain, Ville Mattila, Marie Janssen, Vladyslav
Batyrenko, Cameron Clausen, spike grobstein, Jon Gjengset, Paul Marques Mota,
Jakub Fijałkowski, Mitchell Hamilton, Brad Luyster, Max von Forell, Jake S,
Dimitri Merejkowsky, Chris Biscardi, René Ribaud, Alex Doroshenko, Vincent,
Steven McGuire, Chad Birch, Chris Emery, Bob Ippolito, John Van Enk, metabaron,
Isak Sunde Singh, Philipp Gniewosz, Mads Johansen, lukvol, Ives van Hoorne, Jan
De Landtsheer, Daniel Strittmatter, Evgeniy Dubovskoy, Alex Rudy, Shane Lillie,
Romet Tagobert, Douglas Creager, Corey Alexander, Molly Howell, knutwalker,
Zachary Dremann, Sebastian Ziebell, Julien Roncaglia, Amber Kowalski, T,
queenfartbutt, Paul Kline, Kristoffer Ström, Astrid Bek, Yoh Deadfall, Justin
Ossevoort, Tomáš Duda, Jeremy Banks, Rasmus Larsen, Torben Clasen, C J Silverio,
Walther, Pete Bevin, Shane Sveller, Clara Schultz, jer, Wonwoo Choi, Hawken
Rives, João Veiga, Richard Pringle, Adam Perry, Benjamin Röjder Delnavaz, Matt
Jadczak, Jonathan Knapp, Maximilian, Seth Stadick, brianloveswords, Sean Bryant,
Ember, Sebastian Zimmer, Makoto Nakashima, Geoff Cant, Geoffroy Couprie, Michael
Alyn Miller, o0Ignition0o, Zaki, Raphael Gaschignard, Romain Ruetschi, Ignacio
Vergara, Pascal, Jane Lusby, Nicolas Goy, Ted Mielczarek, Aurora.

</p>
    
  

  

  

  <div>
  
    <p>If you liked this article, please support my work on Patreon!</p>
    <p>
      <a href="https://www.patreon.com/bePatron?u=47556">
        <img src="https://fasterthanli.me/img/patreon/mark-white.png"/>
        <span>Become a Patron</span>
      </a>
    </p>
  
</div>


  

  
</div></div>