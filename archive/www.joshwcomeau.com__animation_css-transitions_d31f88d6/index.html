---
url: https://www.joshwcomeau.com/animation/css-transitions/
title: An Interactive Guide to CSS Transitions
archived_at: 2021-12-13T16:10:17.175562+08:00
---
<div id="readability-page-1" class="page"><div><article><p><h2><a id="introduction">Introduction</a></h2></p><p>The world of web animations has become a sprawling jungle of tools and technologies. Libraries like GSAP and Framer Motion and React Spring have sprung up to help us add motion to the DOM.</p><p>The most fundamental and critical piece, though, is the humble CSS transition. It&#39;s the first animation tool that most front-end devs learn, and it&#39;s a workhorse. Even the most grizzled, weathered animation veterans still reach for this tool often.</p><p>There&#39;s a surprising amount of depth to this topic. In this tutorial, we&#39;ll dig in and learn a bit more about CSS transitions, and how we can use them to create lush, polished animations.</p><div><h2><a name="the-fundamentals" id="the-fundamentals" href="#the-fundamentals"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg><p>Link to this heading</p></a>The fundamentals</h2></div><p>The main ingredient we need to create an animation is some CSS that changes.</p><p>Here&#39;s an example of a button that moves on hover, <em>without animating</em>:</p><p>This snippet uses the <code>:hover</code> pseudoclass to specify an additional CSS declaration when the user&#39;s mouse rests atop our button, similar to an <code>onMouseEnter</code> event in JavaScript.</p><p>To shift the element up, we use <code>transform: translateY(-10px)</code>. While we could have used <code>margin-top</code> for this, <code>transform: translate</code> is a better tool for the job. We&#39;ll see why later.</p><p>By default, changes in CSS happen instantaneously. In the blink of an eye, our button has teleported to a new position! This is incongruous with the natural world, where things happen gradually.</p><p>We can instruct the browser to <em>interpolate</em> from one state to another with the aptly-named <code>transition</code> property:</p><p><code>transition</code> can take a number of values, but only two are required:</p><ol><li><p>The name of the property we wish to animate</p></li><li><p>The duration of the animation</p></li></ol><p>If you plan on animating multiple properties, you can pass it a comma-separated list:</p><pre></pre><div><h2><a name="timing-functions" id="timing-functions" href="#timing-functions"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg><p>Link to this heading</p></a>Timing functions</h2></div><p>When we tell an element to transition from one position to another, the browser needs to work out what each &#34;intermediary&#34; frame should look like.</p><p>For example: let&#39;s say that we&#39;re moving an element from left to right, over a 1-second duration. A smooth animation should run at 60fps<span></span>, which means we&#39;ll need to come up with 60 individual positions between the start and end.</p><p>Let&#39;s start by having them be evenly-spaced:</p><div><p>Click me!</p><p><img alt="" src="https://www.joshwcomeau.com/images/arrow-diagonal-2.png"/></p></div><p>To clarify what&#39;s going on here: each faded circle represents a moment in time. As the circle moves from left to right, these are the frames that were shown to the user. It&#39;s like a flipbook.</p><p>In this animation, we&#39;re using a <strong>linear timing function</strong>. This means that the element moves at a constant pace; our circle moves by the same amount each frame.</p><p>There are several timing functions available to us in CSS. We can specify which one we want to use with the <code>transition-timing-function</code> property:</p><pre></pre><p>Or, we can pass it directly to the <code>transition</code> shorthand property:</p><pre></pre><p><code>linear</code> is rarely the best choice — after all, pretty much nothing in the real world moves this way<span></span>. Good animations mimic the natural world, so we should pick something more organic!</p><p>Let&#39;s run through our options.</p><div><h3><a name="ease-out" id="ease-out" href="#ease-out"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg><p>Link to this heading</p></a>ease-out</h3></div><p><code>ease-out</code> comes charging in like a wild bull, but it runs out of energy. By the end, it&#39;s pootering along like a sleepy turtle.</p><p>Try scrubbing with the timeline; notice how drastic the movement is in the first few frames, and how subtle it becomes towards the end.</p><p>If we were to graph the displacement of the element over time, it&#39;d look something like this:</p><p><strong>When would you use <code>ease-out</code>?</strong> It&#39;s most commonly used when something is entering from off-screen (eg. a modal appearing). It produces the effect that something came hustling in from far away, and settles in front of the user.</p><div><h3><a name="ease-in" id="ease-in" href="#ease-in"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg><p>Link to this heading</p></a>ease-in</h3></div><p><code>ease-in</code>, unsurprisingly, is the opposite of <code>ease-out</code>. It starts slow and speeds up:</p><p>As we saw, <code>ease-out</code> is useful for things that enter into view from offscreen. <code>ease-in</code>, naturally, is useful for the opposite: moving something beyond the bounds of the viewport.</p><p>This combo is useful when something is entering and exiting the viewport, like a modal. We&#39;ll look at how to mix and match timing functions shortly.</p><p>Note that <code>ease-in</code> is pretty much exclusively useful for animations that end with the element offscreen or invisible; otherwise, the sudden stop can be jarring.</p><div><h3><a name="ease-in-out" id="ease-in-out" href="#ease-in-out"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg><p>Link to this heading</p></a>ease-in-out</h3></div><p>Next up, <code>ease-in-out</code>. It&#39;s the combination of the previous two timing functions:</p><p>This timing function is <em>symmetrical</em>. It has an equal amount of acceleration and deceleration.</p><p>I find this curve most useful for anything that happens in a loop (eg. an element fading in and out, over and over).</p><p>It&#39;s a big step-up over <code>linear</code>, but before you go slapping it on everything, let&#39;s look at one more option.</p><p>If I had a bone to pick with the CSS language authors when it comes to transitions, it&#39;s that <code>ease</code> is poorly named. It isn&#39;t descriptive at all; literally all timing functions are eases of one sort or another!</p><p>That nitpick aside, <code>ease</code> is awesome. Unlike <code>ease-in-out</code>, it isn&#39;t symmetrical; it features a brief ramp-up, and a <em>lot</em> of deceleration.</p><p><strong><code>ease</code> is the default value</strong> — if you don&#39;t specify a timing function, <code>ease</code> gets used. Honestly, this feels right to me. <code>ease</code> is a great option in most cases. If an element moves, and isn&#39;t entering or exiting the viewport, <code>ease</code> is usually a good choice.</p><div><h3><a name="custom-curves" id="custom-curves" href="#custom-curves"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg><p>Link to this heading</p></a>Custom curves</h3></div><p>If the provided built-in options don&#39;t suit your needs, you can define your own custom easing curve, using the cubic bézier timing function!</p><pre></pre><p>All of the values we&#39;ve seen so far are really just presets for this <code>cubic-bezier</code> function. It takes 4 numbers, representing 2 control points.</p><p>Bézier curves are really nifty, but they&#39;re beyond the scope of this tutorial. I&#39;ll be writing more about them soon though!</p><p>In the meantime, you can start creating your own Bézier timing functions using this <a href="https://cubic-bezier.com/" rel="noopener noreferrer" target="_blank">wonderful helper from Lea Verou</a>:</p><p>Once you come up with an animation curve you&#39;re satisfied with, click “Copy” at the top and paste it into your CSS!</p><p>You can also pick from this <a href="https://easings.net/" rel="noopener noreferrer" target="_blank">extended set of timing functions</a>. Though beware: a few of the more outlandish options won&#39;t work in CSS.</p><span type="default"><span><span></span><img alt="A screenshot of many different types of timing function curves" srcset="https://www.joshwcomeau.com/_next/image/?url=%2Fimages%2Fcss-transitions%2Feasings-net.png&amp;w=750&amp;q=75 1x, https://www.joshwcomeau.com/_next/image/?url=%2Fimages%2Fcss-transitions%2Feasings-net.png&amp;w=1920&amp;q=75 2x" src="https://www.joshwcomeau.com/_next/image/?url=%2Fimages%2Fcss-transitions%2Feasings-net.png&amp;w=1920&amp;q=75" decoding="async" data-nimg="intrinsic" loading="lazy" data-old-src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></span></span><p>When starting out with custom Bézier curves, it can be hard to come up with a curve that feels natural. With some practice, however, this is an incredibly <em>expressive</em> tool.</p><div><h2><a name="animation-performance" id="animation-performance" href="#animation-performance"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg><p>Link to this heading</p></a>Animation performance</h2></div><p>Earlier, we mentioned that animations ought to run at 60fps. When we do the math, though, we realize that this means the browser only has 16.6 milliseconds to paint each frame. That&#39;s really not much time at all; for reference, it takes us about 100ms-300ms to blink!</p><p>If our animation is too computationally expensive, it&#39;ll appear janky and stuttery. Frames will get dropped, as the device can&#39;t keep up.</p><p>Experience this for yourself by tweaking the new &#34;Frames per second&#34; control:</p><p>In practice, poor performance will often take the form of <em>variable</em> framerates, so this isn&#39;t a perfect simulation.</p><p>Animation performance is a surprisingly deep and interesting area, well beyond the scope of this introductory tutorial. But let&#39;s cover the absolutely-critical, need-to-know bits:</p><ol><li><p>Some CSS properties are wayyy more expensive to animate than others. For example, <code>height</code> is a very expensive property because it affects layout. When an element&#39;s height shrinks, it causes a chain reaction; all of its siblings will also need to move up, to fill the space!</p></li><li><p>Other properties, like <code>background-color</code>, are somewhat expensive to animate. They don&#39;t affect layout, but they do require a fresh coat of paint on every frame, which isn&#39;t cheap.</p></li><li><p>Two properties — <code>transform</code> and <code>opacity</code> — are very cheap to animate. If an animation currently tweaks a property like <code>width</code> or <code>left</code>, it can be <em>greatly improved</em> by moving it to <code>transform</code> (though it isn&#39;t always possible to achieve the exact same effect).</p></li><li><p>Be sure to test your animations on the lowest-end device that your site/app targets. Your development machine is likely many times faster than it.</p></li></ol><p>If you&#39;re interested in learning more about animation performance, I gave a talk on this subject at React Rally. It goes deep into this topic:</p><iframe width="560" height="315" src="https://www.youtube.com/embed/DNGGzwmfouU" title="Saving the Web, 16 Milliseconds at a Time" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><div><h3><a name="hardware-acceleration" id="hardware-acceleration" href="#hardware-acceleration"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg><p>Link to this heading</p></a>Hardware Acceleration</h3></div><p>Depending on your browser and OS, you may have noticed a curious little imperfection in some of the earlier examples:</p><span type="default"><span><span></span><img alt="A mouse hovers over our &#39;hello world&#39; button, and it shifts slightly" srcset="https://www.joshwcomeau.com/_next/image/?url=%2Fimages%2Fcss-transitions%2Ftexture-issue.gif&amp;w=256&amp;q=75 1x, https://www.joshwcomeau.com/_next/image/?url=%2Fimages%2Fcss-transitions%2Ftexture-issue.gif&amp;w=640&amp;q=75 2x" src="https://www.joshwcomeau.com/_next/image/?url=%2Fimages%2Fcss-transitions%2Ftexture-issue.gif&amp;w=640&amp;q=75" decoding="async" data-nimg="intrinsic" loading="lazy" data-old-src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></span></span><p><strong>Pay close attention to the letters.</strong> Notice how they appear to glitch slightly at the start and end of the transition, as if everything was locking into place?</p><p>This happens because of a hand-off between the computer&#39;s CPU and GPU. Let me explain.</p><p>When we animate an element using <code>transform</code> and <code>opacity</code>, the browser will sometimes try to optimize this animation. Instead of rasterizing the pixels on every frame, it transfers everything to the GPU as a texture. GPUs are very good at doing these kinds of texture-based transformations, and as a result, we get a very slick, very performant animation. This is known as “hardware acceleration”.</p><p>Here&#39;s the problem: GPUs and CPUs render things <em>slightly</em> differently. When the CPU hands it to the GPU, and vice versa, you get a snap of things shifting slightly.</p><p>We can fix this problem by adding the following CSS property:</p><pre></pre><p><code>will-change</code> is a property that allows us to hint to the browser that we&#39;re going to animate the selected element, and that it should optimize for this case.</p><p>In practice, what this means is that the browser will let the GPU handle this element <em>all the time</em>. No more handing-off between CPU and GPU, no more telltale “snapping into place”.</p><p><code>will-change</code> lets us be intentional about which elements should be hardware-accelerated. Browsers have their own inscrutable logic around this stuff, and I&#39;d rather not leave it up to chance.</p><p>There&#39;s another benefit to hardware acceleration: we can take advantage of <em>sub-pixel rendering</em>.</p><p>Check out these two boxes. They shift down when you hover/focus them. One of them is hardware-accelerated, and the other one isn&#39;t.</p><p>It&#39;s maybe a bit subtle, depending on your device and your display, but one box moves much more smoothly than the other.</p><p>Properties like <code>margin-top</code> can&#39;t sub-pixel-render, which means they need to round to the nearest pixel, creating a stepped, janky effect. <code>transform</code>, meanwhile, can smoothly shift between pixels, thanks to the GPU&#39;s anti-aliasing trickery.</p><div><h2><a name="ux-touches" id="ux-touches" href="#ux-touches"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg><p>Link to this heading</p></a>UX touches</h2></div><div><h3><a name="action-driven-motion" id="action-driven-motion" href="#action-driven-motion"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg><p>Link to this heading</p></a>Action-driven motion</h3></div><p>Let&#39;s take another look at our rising “Hello World” button.</p><p>As it stands, we have a &#34;symmetrical&#34; transition — the enter animation is the same as the exit animation:</p><ul><li><span><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><p>When the mouse hovers over the element, it shifts up by 10 pixels over 250ms</p></li><li><span><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><p>When the mouse moves away, the element shifts down by 10 pixels over 250ms</p></li></ul><p>A cute little detail is to give each action its own transition settings. For hover animations, I like to make the enter animation quick and snappy, while the exit animation can be a bit more relaxed and lethargic:</p><p>Another common example is modals. It can be useful for modals to enter with an <code>ease-out</code> animation, and to exit with a quicker <code>ease-in</code> animation:</p><p>This is a small detail, but it speaks to a much larger idea.</p><p>I believe most developers think in terms of <em>states</em>: for example, you might look at this situation and say that we have a “hover” state and a default state. Instead, what if we thought in terms of <em>actions</em>? We animate based on what the user is doing, thinking in terms of events, not states. We have a mouse-enter animation and a mouse-leave animation.</p><p>Tobias Ahlin shows how this idea can create next-level semantically-meaningful animations in his blog post,  <a href="https://tobiasahlin.com/blog/meaningful-motion-w-action-driven-animation/" rel="noopener noreferrer" target="_blank">Meaningfun Motion with Action-Driven Animation</a>.</p><div><h3><a name="delays" id="delays" href="#delays"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg><p>Link to this heading</p></a>Delays</h3></div><p>Well, we&#39;ve come pretty far in our quest to become proficient with CSS transitions, but there are a couple final details to go over. Let&#39;s talk about transition delays.</p><p>I believe that just about everyone has had this frustrating experience before:</p><span type="default"><span><span></span><img alt="A mouse moves to access a dropdown, but the dropdown closes before it gets there, since the mouse left the surface area of the dropdown" srcset="https://www.joshwcomeau.com/_next/image/?url=%2Fimages%2Fcss-transitions%2Fdropdown.gif&amp;w=384&amp;q=75 1x, https://www.joshwcomeau.com/_next/image/?url=%2Fimages%2Fcss-transitions%2Fdropdown.gif&amp;w=750&amp;q=75 2x" src="https://www.joshwcomeau.com/_next/image/?url=%2Fimages%2Fcss-transitions%2Fdropdown.gif&amp;w=750&amp;q=75" decoding="async" data-nimg="intrinsic" loading="lazy" data-old-src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></span></span><p><small>Image courtesy of <a href="https://bjk5.com/post/44698559168/breaking-down-amazons-mega-dropdown" rel="noopener noreferrer" target="_blank">Ben Kamens</a></small></p><p>As a developer, you can probably work out why this happens: the dropdown only stays open while being hovered! As we move the mouse diagonally to select a child, our cursor dips out-of-bounds, and the menu closes.</p><p>This problem can be solved in a rather elegant way without needing to reach for JS. We can use <code>transition-delay</code>!</p><pre></pre><p><code>transition-delay</code> allows us to keep things status-quo for a brief interval. In this case, when the user moves their mouse outside <code>.dropdown-wrapper</code>, nothing happens for 300ms. If their mouse re-enters the element within that 300ms window, the transition never takes place.</p><p>After 300ms elapses, the <code>transition</code> kicks in normally, and the dropdown fades out over 400ms.</p><div><h3><a name="doom-flicker" id="doom-flicker" href="#doom-flicker"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg><p>Link to this heading</p></a>Doom flicker</h3></div><p>When an element is moved up or down on hover, we need to be very careful we don&#39;t accidentally introduce a &#34;doom flicker&#34;:</p><div><p><strong>Warning:</strong> This GIF includes flickering motion that may potentially trigger seizures for people with photosensitive epilepsy.</p></div><p>You may have noticed a similar effect on some of the demos on this page!</p><p>The trouble occurs when the mouse is near the element&#39;s boundary. The hover effect takes the element out from under the mouse, which causes it to fall back down under the mouse, which causes the hover effect to trigger again… many times a second.</p><p>How do we solve for this? The trick is to separate the <em>trigger</em> from the <em>effect</em>. Here&#39;s a quick example:</p><p>Our <code>&lt;button&gt;</code> now has a new child, <code>.background</code>. This span houses all of the cosmetic styles (background color, font stuff, etc).</p><p>When we mouse over the plain-jane button, it causes the child to peek out above. The button, however, is stationary.</p><p><strong>Try uncommenting the <code>outline</code> to see exactly what&#39;s going on!</strong></p><div><h2><a name="respecting-motion-preferences" id="respecting-motion-preferences" href="#respecting-motion-preferences"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg><p>Link to this heading</p></a>Respecting motion preferences</h2></div><p>When I see a well-crafted animation on the web, I react with delight and glee. People are different, though, and some folks have a <em>very</em> different reaction: nausea and malaise.</p><p>I&#39;ve written before about <a href="https://www.joshwcomeau.com/react/prefers-reduced-motion/">respecting “prefers-reduced-motion”</a>, an OS-level setting users can toggle to express a preference for less motion. Let&#39;s apply those lessons here, by disabling animations for folks who request it:</p><pre></pre><p>This small tweak means that animations will resolve immediately for users who have gone into their system preferences and toggled a checkbox.</p><p>As front-end developers, we have a certain responsibility to ensure that our products aren&#39;t causing harm. This is a quick step we can perform to make our sites/apps friendlier and safer.</p><div><h2><a name="the-bigger-picture" id="the-bigger-picture" href="#the-bigger-picture"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg><p>Link to this heading</p></a>The bigger picture</h2></div><p>CSS transitions are fundamental, but that doesn&#39;t mean they&#39;re easy. There&#39;s a surprising amount of depth to them; even in this long-winded blog post, I&#39;ve had to cut some stuff out to keep it manageable!</p><p>Web animations are more important than most developers realize. A single transition here or there won&#39;t make or break an experience, but it adds up. In aggregate, well-executed animations can have a surprisingly profound effect on the overall user experience.</p><p>Transitions can make an app feel &#34;real&#34;. They can offer feedback, and communicate in a more-visceral way than copy alone. They can teach people how to use your products. They can spark joy.</p><p>If you enjoyed this tutorial, you might be pleased to know that I&#39;ve built a CSS course. In fact, this blog post is derived from one of the lessons in the Animations module!</p><p>It&#39;s built on the same tech stack as this blog, so it features the same style of embedded interactive widgets, but it goes even further. My course features videos, minigames, workshops, and so much more.</p><p>You can learn more at its official website, <a href="https://css-for-js.dev/" rel="noopener noreferrer" target="_blank">CSS for JavaScript Developers</a>.</p><p>Finally, no interactive lesson is complete without a &#34;sandbox mode&#34;! Play with all the previous settings (and a couple new ones!) and create some generative art with this open-ended widget:</p><div><p><label><span>Timing Function</span></label></p><p><label><span>Shape</span></label></p><p><label><span>Ghost Opacity</span></label></p></div><div><h3>Last Updated</h3><p>September 28th, 2021</p></div></article></div></div>