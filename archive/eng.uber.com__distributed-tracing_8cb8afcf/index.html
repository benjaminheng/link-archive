---
url: https://eng.uber.com/distributed-tracing/
title: Evolving Distributed Tracing at Uber Engineering
archived_at: 2021-12-13T16:09:18.773765+08:00
---
<div id="readability-page-1" class="page"><div>
            
                                <p><img src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2017/02/Distributed_Tracing_Header-768x329.png" alt="Evolving Distributed Tracing at Uber Engineering" title="Evolving Distributed Tracing at Uber Engineering"/>
                                            </p>
            
            <p><span>Distributed tracing is quickly becoming a must-have component in the tools that organizations use to monitor their complex, </span><a href="https://eng.uber.com/building-tincup/" target="_blank" rel="noopener noreferrer"><span>microservice-based architectures</span></a><span>. At Uber Engineering, our open source distributed tracing system </span><a href="http://uber.github.io/jaeger/" target="_blank" rel="noopener noreferrer"><span>Jaeger</span></a><span> saw large-scale internal adoption throughout 2016, integrated into hundreds of microservices and now recording thousands of traces every second. As we start the new year, here is the story of how we got here, from investigating off-the-shelf solutions like </span><a href="http://zipkin.io/" target="_blank" rel="noopener noreferrer"><span>Zipkin</span></a><span>, to why we switched from pull to push architecture, and how distributed tracing will continue to evolve in 2017.</span></p>
<h3><span>From Monolith to Microservices</span></h3>
<p><span>As Uber’s business has grown exponentially, so has our software architecture complexity. A little over a year ago, in fall 2015, we had around five hundred microservices. As of early 2017, we have over two thousand. This is in part due to the increasing number of business features—user-facing ones like </span><a href="https://www.ubereats.com" target="_blank" rel="noopener noreferrer"><span>UberEATS</span></a><span> and </span><a href="https://rush.uber.com/how-it-works/" target="_blank" rel="noopener noreferrer"><span>UberRUSH</span></a><span>—as well as internal functions like fraud detection, data mining, and maps processing. The other reason complexity increased was a move away from </span><a href="https://eng.uber.com/soa/" target="_blank" rel="noopener noreferrer"><span>large monolithic applications</span></a><span> to a distributed microservices architecture.</span></p>
<p><span>As it often happens, moving into a microservices ecosystem brings its own challenges. Among them is the loss of visibility into the system, and the complex interactions now occurring between services. </span><a href="https://people.uber.com/eng/" target="_blank" rel="noopener noreferrer"><span>Engineers at Uber</span></a><span> know that our technology has a direct impact on people’s livelihoods. The reliability of the system is paramount, yet it is not possible without observability. Traditional </span><a href="http://eng.uber.com/argos/" target="_blank" rel="noopener noreferrer"><span>monitoring tools</span></a><span> such as metrics and distributed logging still have their place, but they often fail to provide visibility </span><i><span>across services</span></i><span>. This is where distributed tracing thrives.</span></p>
<h3><span>Tracing Uber’s Beginnings </span></h3>
<p><span>The first widely used tracing system at Uber was called Merckx, named after </span><a href="https://en.wikipedia.org/wiki/Eddy_Merckx" target="_blank" rel="noopener noreferrer"><span>the fastest cyclist in the world</span></a><span> during his time. Merckx quickly answered complex queries about Uber’s monolithic Python backend. It made queries like “find me requests where the user was logged in </span><i><span>and</span></i><span> the request took more than two seconds </span><i><span>and</span></i><span> only certain databases were used </span><i><span>and</span></i><span> a transaction was held open for more than 500 ms” possible. The profiling data was organized into a tree of blocks, with each block representing a certain operation or a remote call, similar to the notion of “span” in the </span><a href="http://opentracing.io/" target="_blank" rel="noopener noreferrer"><span>OpenTracing API</span></a><span>. Users could run ad hoc queries against the data stream in </span><a href="https://kafka.apache.org/" target="_blank" rel="noopener noreferrer"><span>Kafka</span></a><span> using command-line tools. They could also use a web UI to view predefined digests that summarized the high-level behavior of API endpoints and </span><a href="http://docs.celeryproject.org/en/latest/" target="_blank" rel="noopener noreferrer"><span>Celery</span></a><span> tasks.</span></p>
<figure id="attachment_858" aria-describedby="caption-attachment-858"><img loading="lazy" src="http://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2017/02/1-Merckx-tree.png" width="600" height="590" srcset="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2017/02/1-Merckx-tree.png 686w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2017/02/1-Merckx-tree-300x295.png 300w" sizes="(max-width: 600px) 100vw, 600px"/><figcaption id="caption-attachment-858">Merckx modeled the call graph as a tree of blocks, with each block representing an operation within the application, such as a database call, an <a href="https://en.wikipedia.org/wiki/Remote_procedure_call" target="_blank" rel="noopener noreferrer">RPC</a>, or even a library function like parsing JSON.</figcaption></figure>

<p><span>Merckx instrumentation was automatically applied to a number of infrastructure libraries in Python, including HTTP clients and servers, SQL queries, </span><a href="https://redis.io/" target="_blank" rel="noopener noreferrer"><span>Redis</span></a><span> calls, and even JSON serialization. The instrumentation recorded certain performance metrics and metadata about each operation, such as the URL for an HTTP call, or SQL query for database calls. It also captured information like how long database transactions have remained open, and which database shards and replicas were accessed.</span></p>
<figure id="attachment_859" aria-describedby="caption-attachment-859"><a href="http://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2017/02/2-1-EngBlog-Distributed-Tracing-at-Uber.png" target="_blank" rel="noopener noreferrer"><img loading="lazy" src="http://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2017/02/2-1-EngBlog-Distributed-Tracing-at-Uber.png" width="600" height="338" srcset="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2017/02/2-1-EngBlog-Distributed-Tracing-at-Uber.png 960w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2017/02/2-1-EngBlog-Distributed-Tracing-at-Uber-300x169.png 300w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2017/02/2-1-EngBlog-Distributed-Tracing-at-Uber-768x432.png 768w" sizes="(max-width: 600px) 100vw, 600px"/></a><figcaption id="caption-attachment-859">Merckx architecture is a pull model from a stream of instrumentation data in Kafka.</figcaption></figure>

<p><span>The major shortcoming with Merckx was its design for the days of a monolithic API at Uber. Merckx lacked any concept of distributed context propagation. It recorded SQL queries, Redis calls, and even calls to other services, but there was no way to go more than one level deep. One other interesting Merckx limitation was that many advanced features like database transaction tracking really only worked under </span><a href="https://uwsgi-docs.readthedocs.io/en/latest/" target="_blank" rel="noopener noreferrer"><span>uWSGI</span></a><span>, since Merckx data was stored in a global, thread-local storage. Once Uber started adopting </span><a href="http://www.tornadoweb.org/" target="_blank" rel="noopener noreferrer"><span>Tornado</span></a><span>, an asynchronous application framework for Python services, the thread-local storage was unable to represent many concurrent requests running in the same thread on Tornado’s IOLoop. We began to realize how important it was to have a solid story for keeping request state around and propagating it correctly, without relying on global variables or global state.</span></p>
<h3><span>Next, Tracing in TChannel</span></h3>
<p><span>At the beginning of 2015, we started the development of </span><a href="https://github.com/uber/tchannel" target="_blank" rel="noopener noreferrer"><span>TChannel</span></a><span>, a network multiplexing and framing protocol for RPC. One of the design goals of the protocol was to have </span><a href="https://research.google.com/pubs/pub36356.html" target="_blank" rel="noopener noreferrer"><span>Dapper</span></a><span>-style distributed tracing built into the protocol as a first-class citizen. Toward that goal, the </span><a href="https://github.com/uber/tchannel/blob/master/docs/protocol.md" target="_blank" rel="noopener noreferrer"><span>TChannel protocol specification</span></a><span> defined </span><a href="https://github.com/uber/tchannel/blob/master/docs/protocol.md#tracing" target="_blank" rel="noopener noreferrer"><span>tracing fields</span></a><span> as part of the binary format.</span></p>
<p><span>spanid:8 parentid:8 traceid:8 traceflags:1</span></p>
<table>
<thead>
<tr>
<th>field</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<div><p>spanid</p></div>
</td>
<td>int64</td>
<td>that identifies the current <em>span</em></td>
</tr>
<tr>
<td>
<div><p>parentid</p></div>
</td>
<td>int64</td>
<td>of the previous <em>span</em></td>
</tr>
<tr>
<td>
<div><p>traceid</p></div>
</td>
<td>int64</td>
<td>assigned by the original requestor</td>
</tr>
<tr>
<td>
<div><p>traceflags</p></div>
</td>
<td>uint8</td>
<td>bit flags field</td>
</tr>
</tbody>
</table>
<p><em><span>Tracing fields appear as part of the binary format in <a href="https://github.com/uber/tchannel/blob/master/docs/protocol.md#tracing" target="_blank" rel="noopener noreferrer">TChannel protocol specification</a>.</span></em></p>
<p><span>In addition to the protocol specification, we released several open-source client libraries that implement the protocol in different languages. One of the design principles for those libraries was to have the notion of a </span><i><span>request context</span></i><span> that the application was expected to pass through from the server endpoints to the downstream call sites. For example, in </span><a href="https://github.com/uber/tchannel-go/" target="_blank" rel="noopener noreferrer"><span>tchannel-go</span></a><span>, the signature to make an </span><a href="https://github.com/uber/tchannel-go/blob/dev/json/call.go#L102" target="_blank" rel="noopener noreferrer"><span>outbound call with JSON encoding</span></a><span> required the context as the first argument:</span></p>
<p><span>func (c *Client) Call(ctx Context, method string, arg, resp interface{}) error {..}</span></p>
<p><span>The TChannel libraries encouraged application developers to write their code with distributed context propagation in mind.</span></p>
<p><span>The client libraries had built-in support for distributed tracing by marshalling the tracing context between the wire representation and the in-memory context object, and by creating tracing spans around service handlers and the outbound calls. Internally, the spans were represented in a format nearly identical to the </span><a href="http://zipkin.io/" target="_blank" rel="noopener noreferrer"><span>Zipkin tracing system</span></a><span>, including the use of Zipkin-specific annotations, such as “cs” (Client Send) and “cr” (Client Receive). TChannel used a tracing reporter interface to send the collected tracing spans out of process to the tracing system’s backend. The libraries came with a default reporter implementation that used TChannel itself and </span><a href="https://github.com/uber-archive/hyperbahn" target="_blank" rel="noopener noreferrer"><span>Hyperbahn</span></a><span>, the discovery and routing layer, to send the spans in Thrift format to a cluster of collectors.</span></p>
<p><span>TChannel client libraries got us close to the working distributing tracing system Uber needed, providing the following building blocks:</span></p>
<ul>
<li><span>Interprocess propagation of tracing context, in-band with the requests</span></li>
<li><span>Instrumentation API to record tracing spans</span></li>
<li><span>In-process propagation of the tracing context</span></li>
<li><span>Format and mechanism for reporting tracing data out of process to the tracing backend</span></li>
</ul>
<p><span>The only missing piece was the tracing backend itself. Both the wire format of the tracing context and the default Thrift format used by the reporter have been designed to make it very straightforward to integrate TChannel with a Zipkin backend. However, at the time the only way to send spans to Zipkin was via </span><a href="https://github.com/facebookarchive/scribe" target="_blank" rel="noopener noreferrer"><span>Scribe</span></a><span>, and the only performant data store that Zipkin supported was </span><a href="http://cassandra.apache.org/" target="_blank" rel="noopener noreferrer"><span>Cassandra</span></a><span>. Back then, we had no direct operational experience for either of those technologies, so we built a prototype backend that combined some custom components with the Zipkin UI to form a complete tracing system.</span></p>
<figure id="attachment_861" aria-describedby="caption-attachment-861"><a href="http://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2017/02/3-4-EngBlog-Distributed-Tracing-at-Uber.png" target="_blank" rel="noopener noreferrer"><img loading="lazy" src="http://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2017/02/3-4-EngBlog-Distributed-Tracing-at-Uber.png" width="600" height="338" srcset="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2017/02/3-4-EngBlog-Distributed-Tracing-at-Uber.png 960w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2017/02/3-4-EngBlog-Distributed-Tracing-at-Uber-300x169.png 300w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2017/02/3-4-EngBlog-Distributed-Tracing-at-Uber-768x432.png 768w" sizes="(max-width: 600px) 100vw, 600px"/></a><figcaption id="caption-attachment-861">The architecture of the prototype backend for TChannel-generated traces was a push model with custom collectors, custom storage, and the open source Zipkin UI.</figcaption></figure>

<p><span>The success of distributed tracing systems at other major tech companies such as Google and Twitter was predicated on the availability of RPC frameworks, Stubby and </span><a href="http://twitter.github.io/finagle/" target="_blank" rel="noopener noreferrer"><span>Finagle</span></a><span> respectively, widely used at those companies. </span></p>
<p><span>Similarly, out-of-the-box tracing capabilities in TChannel were a big step forward. The deployed backend prototype started receiving traces from several dozen services right away. More services were being built using TChannel, but full-scale production rollout and widespread adoption were still problematic. The prototype backend and its </span><a href="https://en.wikipedia.org/wiki/Riak" target="_blank" rel="noopener noreferrer"><span>Riak</span></a><span>/</span><a href="http://lucene.apache.org/solr/" target="_blank" rel="noopener noreferrer"><span>Solr</span></a><span> based storage had some issues scaling up to Uber’s traffic, and several query capabilities were missing to properly interoperate with the Zipkin UI. And despite the rapid adoption of TChannel by new services, Uber still had a large number of services not using TChannel for RPC; in fact, most of the services responsible for running the core business functions ran without TChannel. These services were implemented in four major programming languages (Node.js, Python, Go, and Java), using a variety of different frameworks for interprocess communication. This heterogeneity of the technology landscape made deploying distributed tracing at Uber a much more difficult task than at places like Google and Twitter.</span></p>
<h3><span>Building Jaeger in New York City</span></h3>
<p><span>The </span><a href="https://www.meetup.com/Uber-Engineering-Events-New-York/" target="_blank" rel="noopener noreferrer"><span>Uber NYC Engineering organization</span></a><span> began in early 2015, with two primary teams: Observability on the infrastructure side and Uber Everything on the product side (including UberEATS and UberRUSH). Since distributed tracing is a form of production monitoring, it was a good fit for Observability. </span></p>
<p><span>We formed the Distributed Tracing team with two engineers and two objectives: transform the existing prototype into a full-scale production system, and make distributed tracing available to and adopted by all Uber microservices. We also needed a code name for the project. Naming things is one of the </span><a href="http://martinfowler.com/bliki/TwoHardThings.html" target="_blank" rel="noopener noreferrer"><span>two hard problems in computer science</span></a><span>, so it took us a couple weeks of brainstorming words with the themes of tracing, detectives, and hunting, until we settled on the name Jaeger (ˈyā-gər), German for hunter or hunting attendant.</span></p>
<p><span>The NYC team already had the operational experience of running Cassandra clusters, which was the database directly supported by the Zipkin backend, so we decided to abandon the Riak/Solr based prototype. We reimplemented the collectors in Go to accept TChannel traffic and store it in Cassandra in the binary format compatible with Zipkin. This allowed us to use Zipkin web and query services without any modifications, and also provided the missing functionality of searching traces by custom tags. We have also built in a dynamically configurable multiplication factor into each collector to multiply the inbound traffic </span><i><span>n</span></i><span> times for the purpose of stress testing the backend with production data.</span></p>
<figure id="attachment_862" aria-describedby="caption-attachment-862"><a href="http://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2017/02/4-5-EngBlog-Distributed-Tracing-at-Uber.png" target="_blank" rel="noopener noreferrer"><img loading="lazy" src="http://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2017/02/4-5-EngBlog-Distributed-Tracing-at-Uber.png" width="600" height="338" srcset="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2017/02/4-5-EngBlog-Distributed-Tracing-at-Uber.png 960w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2017/02/4-5-EngBlog-Distributed-Tracing-at-Uber-300x169.png 300w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2017/02/4-5-EngBlog-Distributed-Tracing-at-Uber-768x432.png 768w" sizes="(max-width: 600px) 100vw, 600px"/></a><figcaption id="caption-attachment-862">The early Jaeger architecture still relied on Zipkin UI and Zipkin storage format.</figcaption></figure>

<p><span>The second order of business was to make tracing available to all the existing services that were not using TChannel for RPC. We spent the next few months building client side libraries in Go, Java, Python, and Node.js to support instrumentation of arbitrary services, including HTTP-based ones. Even though the Zipkin backend was fairly well known and popular, it lacked a good story on the instrumentation side, especially outside of the Java/</span><a href="http://www.scala-lang.org/" target="_blank" rel="noopener noreferrer"><span>Scala</span></a><span> ecosystem. We considered various open source instrumentation libraries, but they were maintained by different people with no guarantee of interoperability on the wire, often with completely different APIs, and most requiring Scribe or Kafka as the transport for reporting spans. We ultimately decided to write our own libraries that would be integration tested for interoperability, support the transport that we needed, and, most importantly, provide a consistent instrumentation API in different languages. All our client libraries have been build to support the OpenTracing API from inception.</span></p>
<p><span>Another novel feature that we built into the very first versions of the client libraries was the ability to poll the tracing backend for the </span><i><span>sampling strategy</span></i><span>. When a service receives a request that has no tracing metadata, the tracing instrumentation usually starts a new trace for that request by generating a new random trace ID. However, most production tracing systems, especially those that have to deal with the scale of Uber, do not profile every single trace or record it in storage. Doing so would create a prohibitively large volume of traffic from the services to the tracing backend, possibly orders of magnitude larger than the actual business traffic handled by the services. Instead, most tracing systems sample only a small percentage of traces and only profile and record those sampled traces. The exact algorithm for making a sampling decision is what we call a sampling strategy. Examples of sampling strategies include:</span></p>
<ul>
<li><span>Sample everything. This is useful for testing, but expensive in production!</span></li>
<li><span>A probabilistic approach, where a given trace is sampled randomly with a certain fixed probability.</span></li>
<li>A rate limiting approach, where X number of traces are sampled per time unit. For example, a variant of the <a href="https://en.wikipedia.org/wiki/Leaky_bucket" target="_blank" rel="noopener noreferrer"><span>leaky bucket algorithm</span></a><span> might be used.</span></li>
</ul>
<p><span>Most existing Zipkin-compatible instrumentation libraries support probabilistic sampling, but they expect the sampling rate to be configured on initialization. Such an approach leads to several serious problems when used at scale:</span></p>
<ul>
<li><span>A given service has little insight about the impact of the sampling rate on the overall traffic to the tracing backend. For example, even if the service itself has a moderate Query Per Second (QPS) rate, it could be calling another downstream service that has a very high fanout factor or using extensive instrumentation that results in a lot of tracing spans.</span></li>
<li><span>At Uber, business traffic exhibits strong daily seasonality; more people take rides during peak hours. A fixed sampling probability might be too low for off-peak traffic, yet too high for peak traffic.</span></li>
</ul>
<p><span>The polling feature in Jaeger client libraries was designed to address these problems. By moving the decision about the appropriate sampling strategy to the tracing backend, we free service developers from guessing about the appropriate sampling rate. This also allows the backend to dynamically adjust the sampling rates as the traffic patterns change. The diagram below shows the feedback loop from collectors to the client libraries.</span></p>
<p><span>The first versions of the client libraries still used TChannel to send tracing spans out of process by submitting them directly to collectors, so the libraries depended on Hyperbahn for discovery and routing. This dependency created unnecessary friction for engineers adopting tracing for their services, both on the infrastructure level and on the number of extra libraries they had to pull into the service, potentially creating </span><a href="https://en.wikipedia.org/wiki/Dependency_hell" target="_blank" rel="noopener noreferrer"><span>dependency hell</span></a><span>.</span></p>
<p><span>We addressed that by implementing the </span><span>jaeger-agent</span><span> sidecar process, deployed to all hosts as an infrastructure component just like the agents collecting metrics. All routing and discovery dependencies were encapsulated in the </span><span>jaeger-agent</span><span>, and we redesigned the client libraries to report tracing spans to a local </span><a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol" target="_blank" rel="noopener noreferrer"><span>UDP</span></a><span> port and poll the agent on the loopback interface for the sampling strategies. Only the basic networking libraries are required by the new clients. This architectural change was a step toward our vision of using post-trace sampling: buffering traces in memory in the agents.</span></p>
<figure id="attachment_863" aria-describedby="caption-attachment-863"><a href="http://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2017/02/5-6-EngBlog-Distributed-Tracing-at-Uber.png" target="_blank" rel="noopener noreferrer"><img loading="lazy" src="http://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2017/02/5-6-EngBlog-Distributed-Tracing-at-Uber.png" width="600" height="338" srcset="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2017/02/5-6-EngBlog-Distributed-Tracing-at-Uber.png 960w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2017/02/5-6-EngBlog-Distributed-Tracing-at-Uber-300x169.png 300w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2017/02/5-6-EngBlog-Distributed-Tracing-at-Uber-768x432.png 768w" sizes="(max-width: 600px) 100vw, 600px"/></a><figcaption id="caption-attachment-863">The current Jaeger architecture: backend components implemented in Go, client libraries in four languages supporting OpenTracing standard, a <a href="https://facebook.github.io/react/" target="_blank" rel="noopener noreferrer">React</a>-based web front-end, and a post-processing and aggregation data pipeline based on <a href="http://spark.apache.org/" target="_blank" rel="noopener noreferrer">Apache Spark</a>.</figcaption></figure>

<h3><span>Turnkey Distributed Tracing</span></h3>
<p><span>The Zipkin UI was the last piece of third-party software we had in Jaeger. Having to store spans in Cassandra in Zipkin Thrift format for compatibility with the UI limited our backend and data model. In particular, the Zipkin model did not support two important features available in the OpenTracing standard and our client libraries: a </span><span>key-value logging API and traces represented as more general directed acyclic graphs rather than just trees of spans. We decided to take the plunge, renovate the data model in our backend, and write a new UI. Shown below, the new data model natively supports both key-value logging and span references. It also optimizes the volume of data sent out of process by avoiding process tag duplication in every span:</span></p>
<figure id="attachment_864" aria-describedby="caption-attachment-864"><a href="http://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2017/02/6-OpenTracing-data-model-example.png" target="_blank" rel="noopener noreferrer"><img loading="lazy" src="http://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2017/02/6-OpenTracing-data-model-example-1024x576.png" width="600" height="337" srcset="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2017/02/6-OpenTracing-data-model-example-1024x576.png 1024w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2017/02/6-OpenTracing-data-model-example-300x169.png 300w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2017/02/6-OpenTracing-data-model-example-768x432.png 768w" sizes="(max-width: 600px) 100vw, 600px"/></a><figcaption id="caption-attachment-864">The Jaeger data model natively supports both key-value logging and span references.</figcaption></figure>
<p><span>We are currently completing the upgrade of the backend pipeline to the new data model and a new, better optimized Cassandra schema. To take advantage of the new data model, we have implemented a new Jaeger-query service in Go and a brand new web UI built with React. The initial version of the UI mostly reproduces existing features of the Zipkin UI, but it was architected to be easily extensible with new features and components as well as embeddable into other UIs as a React component itself. For example, a user can select a number of different views to visualize trace results, such as a histogram of trace durations or the service’s cumulative time in the trace:</span></p>
<figure id="attachment_866" aria-describedby="caption-attachment-866"><a href="http://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2017/02/7-Screen-Shot-Search-Results.png" target="_blank" rel="noopener noreferrer"><img loading="lazy" src="http://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2017/02/7-Screen-Shot-Search-Results-1024x542.png" width="600" height="317" srcset="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2017/02/7-Screen-Shot-Search-Results-1024x542.png 1024w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2017/02/7-Screen-Shot-Search-Results-300x159.png 300w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2017/02/7-Screen-Shot-Search-Results-768x406.png 768w" sizes="(max-width: 600px) 100vw, 600px"/></a><figcaption id="caption-attachment-866">The Jaeger UI shows trace search results. In the top right corner, a duration vs. time scatter plot gives a visual representation of the results and drill-down capability.</figcaption></figure>

<p><span>As another example, a single trace can be viewed according to specific use cases. The default rendering is a time sequence; other views include a directed acyclic graph or a critical path diagram:</span></p>
<figure id="attachment_865" aria-describedby="caption-attachment-865"><a href="http://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2017/02/8-Screen-Shot-Trace-View.png" target="_blank" rel="noopener noreferrer"><img loading="lazy" src="http://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2017/02/8-Screen-Shot-Trace-View-1024x521.png" width="600" height="305" srcset="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2017/02/8-Screen-Shot-Trace-View-1024x521.png 1024w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2017/02/8-Screen-Shot-Trace-View-300x153.png 300w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2017/02/8-Screen-Shot-Trace-View-768x391.png 768w" sizes="(max-width: 600px) 100vw, 600px"/></a><figcaption id="caption-attachment-865">The Jaeger UI shows a single trace’s details. At the top of the screen is a minimap diagram of the trace that supports easier navigation within large traces.</figcaption></figure>

<p><span>By replacing the remaining Zipkin components in our architecture with Jaeger’s own components, we position Jaeger to be a turnkey, end-to-end distributed tracing system.</span></p>
<p><span>We believe it is crucial that the instrumentation libraries be inherently part of Jaeger, to guarantee both their compatibility with the Jaeger backend and interoperability amongst themselves via continuous integration testing. (This guarantee was unavailable in the Zipkin ecosystem.) In particular, the interoperability across all supported languages (currently Go, Java, Python, and Node.js) and all supported wire transports (currently HTTP and TChannel) is tested as part of every pull request with the help of the </span><a href="https://github.com/crossdock/crossdock" target="_blank" rel="noopener noreferrer"><span>crossdock</span></a><span> framework, written by the Uber Engineering RPC team. You can find the details of the Jaeger client integration tests in the </span><a href="https://github.com/uber/jaeger-client-go/tree/master/crossdock" target="_blank" rel="noopener noreferrer"><span>jaeger-client-go</span></a><span> crossdock repository. At the moment, all Jaeger client libraries are available as </span><a href="http://uber.github.io/" target="_blank" rel="noopener noreferrer"><span>open source</span></a><span>:</span></p>
<ul>
<li><a href="https://github.com/uber/jaeger-client-go" target="_blank" rel="noopener noreferrer"><span>Go</span></a></li>
<li><a href="https://github.com/uber/jaeger-client-java" target="_blank" rel="noopener noreferrer"><span>Java</span></a></li>
<li><a href="https://github.com/uber/jaeger-client-node" target="_blank" rel="noopener noreferrer"><span>Node.js</span></a></li>
<li><a href="https://github.com/uber/jaeger-client-python" target="_blank" rel="noopener noreferrer"><span>Python</span></a></li>
</ul>
<p><span>We are migrating the backend and the UI code to Github, and plan to have the full Jaeger source code available soon. If you are interested in the progress, watch the </span><a href="https://github.com/uber/jaeger" target="_blank" rel="noopener noreferrer"><span>main repository</span></a><span>. We welcome contributions, and would love to see others give Jaeger a try. While we are pleased with the progress so far, the story of distributed tracing at Uber is still far from finished.</span></p>
<p><i><span>Yuri Shkuro is a staff software engineer in the Uber New York City engineering office, and is in all likelihood diligently working on Jaeger and other </span></i><a href="http://uber.github.io/" target="_blank" rel="noopener noreferrer"><i><span>Uber Engineering open source contributions</span></i></a><i><span> right now.</span></i></p>
<p>Editor Update April 15, 2017: <a href="http://jaeger.readthedocs.io/en/latest/news/" target="_blank" rel="noopener noreferrer"><strong>Jaeger is now officially open source, with resulting documentation</strong>.</a></p>
<p>Editor Update April 23, 2020: In September 2017, Jaeger <strong><a href="https://www.cncf.io/blog/2017/09/13/cncf-hosts-jaeger/" target="_blank" rel="noopener noreferrer">joined the Cloud Native Computing Foundation</a></strong> as an incubation project, and in October 2019,<strong> <a href="https://www.cncf.io/announcement/2019/10/31/cloud-native-computing-foundation-announces-jaeger-graduation/" target="_blank" rel="noopener noreferrer">it graduated to the foundation</a></strong> as a top-level project.</p>
        </div></div>