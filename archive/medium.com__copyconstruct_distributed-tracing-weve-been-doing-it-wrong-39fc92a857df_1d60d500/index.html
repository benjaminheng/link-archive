---
url: https://medium.com/@copyconstruct/distributed-tracing-weve-been-doing-it-wrong-39fc92a857df
title: Distributed Tracing — we’ve been doing it wrong - Cindy Sridharan - Medium
archived_at: 2021-05-23T00:58:50.800048+08:00
---
<div id="readability-page-1" class="page"><div><div><p><a rel="noopener" href="https://medium.com/?source=post_page-----39fc92a857df--------------------------------"><img alt="Cindy Sridharan" src="https://miro.medium.com/fit/c/56/56/1*qO8507PXndPzq2TSZjYlAw.jpeg" width="28" height="28"/></a></p></div><p id="e422"><em>Many thanks to </em><a href="https://twitter.com/behinddamasque" rel="noopener nofollow"><em>Ramon Nogueira</em></a><em> and </em><a href="https://twitter.com/sargun" rel="noopener nofollow"><em>Sargun Dhillo</em></a><em>n for reading a draft of this post.</em></p><p id="bdd3"><a href="https://opentracing.io/docs/overview/what-is-tracing/" rel="noopener nofollow">Distributed Tracing</a> is often considered hard to deploy and its value proposition <a href="https://twitter.com/mattklein123/status/1049813546077323264" rel="noopener nofollow">questionable at best</a>. A variety of reasons are attributed to why tracing is “difficult”, an apocryphal concern being the difficulty in instrumenting every component of a distributed system to forward the appropriate headers along with every request. While this might be a valid concern, ultimately it’s not an insurmountable problem. This, incidentally, doesn’t explain why tracing isn’t typically used much by developers, even once it is deployed.</p><p id="00c9">The ha<span id="rmm"><span id="rmm">r</span></span>d part about distributed tracing isn’t collecting the traces, standardizing on trace propagation and exposition formats, or deciding when, where and how to sample. I’m by no means <em>trivializing </em>these “ingest problems” — indeed, there exist significant technical and (if we’re looking at <a href="https://opentelemetry.io" rel="noopener nofollow">truly open source standards and protocols</a>) political challenges to overcome to get to the ideal when these can be considered “solved problems”.</p><p id="ad3c">However, even if hypothetically all of these problems were to be solved, there’s a good likelihood that nothing much has significantly changed as far as the <em>end user experience</em> is concerned. Tracing might still remain something that, once deployed, doesn’t unlock enough value to be of any practical use in the most common debugging scenarios.</p><h2 id="2b69">The Many Faces of Tracing</h2><p id="d5dd">Distributed tracing comprises of several disparate components:</p><p id="2a63">— instrumentation of application and middleware<br/> — distributed context propagation<br/> — trace ingest<br/> — trace storage<br/> — trace retrieval and visualization</p><p id="c125">An awful lot of conversations about distributed tracing pivot around treating it as some sort of unary undertaking whose sole purpose is to aid in full system diagnostics, in no small part owing to how distributed tracing was historically marketed. The <a href="https://blog.twitter.com/engineering/en_us/a/2012/distributed-systems-tracing-with-zipkin.html" rel="noopener nofollow">blog post that was w</a>ritten when Zipkin was open-sourced mentioned that <em>it [Zipkin] makes Twitter faster. </em>Initial commercial tracing offerings, likewise, were marketed as <a href="https://en.wikipedia.org/wiki/Application_performance_management" rel="noopener nofollow">APM tools</a>.</p><p id="edf0">Traces contain incredibly valuable data with the potential to aid in efforts such as: testing in production, running disaster recovery tests, enabling fault injection testing and so forth. Some companies, in fact, already use trace data for such purposes. For a start, <a href="https://medium.com/jaegertracing/embracing-context-propagation-7100b9b6029a" rel="noopener">universal context propagation</a> has several other uses than to simply ferry spans into a storage system. Uber is known to use tracing data to <a href="https://twitter.com/copyconstruct/status/1121231388999503872" rel="noopener nofollow">demarcate test traffic from production</a> traffic. Facebook is <a href="https://twitter.com/copyconstruct/status/1052072692327710720" rel="noopener nofollow">known to use trace data</a> for critical path analysis and to shift traffic during regular disaster recovery tests. Facebook <a href="https://www.infoq.com/presentations/canopy-scalable-tracing-analytics-facebook/" rel="noopener nofollow">is also known to use Jupyter notebooks</a> to enable developers to run arbitrary queries over trace data. The <a href="https://people.ucsc.edu/~palvaro/molly.pdf" rel="noopener nofollow">LDFI folks</a> are known <a href="https://www.usenix.org/sites/default/files/conference/protected-files/sre19amer_slides_raina.pdf" rel="noopener nofollow">to use distributed traces </a>for fault injection testing. None of these strictly pertains to the <em>debugging</em> scenario, where an engineer is trying to troubleshoot an issue by looking at a trace.</p><p id="653e">When it <em>does</em> come to the debugging<em> </em>scenario, the primary interface remains what I call the <em>traceview </em>(though some people also refer to this as a <em>Gantt chart </em>or <em>waterfall diagram</em>)<em>. </em>By <em>traceview</em>, <a href="https://www.google.com/search?tbm=isch&amp;source=hp&amp;biw=1450&amp;bih=900&amp;ei=PvgjXZGjC8T19AOQ26egAQ&amp;q=distributed+tracing&amp;oq=distributed+tracing&amp;gs_l=img.3..0l2j0i5i30l2j0i8i30j0i24l5.1101.4206..4450...0.0..0.172.2434.0j19......0....1..gws-wiz-img.....0.u0RC6yoMOY0" rel="noopener nofollow">I refer to all the spans and attendant metadata that together constitute a <em>trace</em></a>. Every open source tracing system as well as commercial tracing solution offers a <em>traceview</em> based<em> </em>UI to visualize, query and filter traces<em>.</em></p><p id="9a06">The problem with every last tracing system I’ve seen so far is that the ultimate <em>visualization </em>(the <em>traceview</em>)<em> </em>closely mirrors the core implementation detail of how a trace is generated. Even when alternative visualizations are offered (heatmap, service topology views, latency histograms) they ultimately lead to a <em>traceview</em>.</p><p id="08d4">I’ve <a href="https://twitter.com/copyconstruct/status/1099562417858609153" rel="noopener nofollow">lamented in the past</a> how most of the “innovation” I see happening in the tracing space on the UI/UX front appears to be limited to including <a href="https://opentracing.io/docs/overview/tags-logs-baggage/#logs" rel="noopener nofollow">additional metadata in a trace, embedding high-cardinality information</a> in traces, or providing the ability to drill down into specific spans or enabling <em>intertrace</em> and <em>intratrace</em> queries, all while cleaving to the <em>traceview </em>as the primary visualization medium<em>. </em>So long as this remains the case, distributed tracing will, at best, come a poor fourth to metrics, logs and stacktraces for debugging purposes, and at worst end up proving to be a time and money sink.</p><p id="6204">A <em>traceview</em> is meant to provide a bird’s eye view of the lifecycle of a single request across every single component of a distributed system which the request traverses through, with some of the more advanced tracing systems offering the ability to drill down into individual spans and look at the breakdown of timing <em>within </em>a single process (when spans are emitted at the function boundaries).</p><p id="0da4">The foundational premise of a microservices architecture is that as the business requirements grow more complex, so will the organization structure. Proponents of microservices argue that decomposing different business functionality into standalone services will enable small, autonomous teams to own the end-to-end lifecycle of such services, unlocking the ability to build, test and deploy these services independently. However, since any such decomposition comes at the cost of a loss of visibility into how each service interacts with the others, distributed tracing is purported to be an indispensable tool for <em>debugging </em>the complex interactions between the services <em>in unison</em>.</p><p id="a6f5">If you truly have a <a href="https://twitter.com/msuriar/status/1110244877424578560" rel="noopener nofollow">mind-bogglingly complex distributed system</a>, then no one single person can have a <em>complete</em> understanding of the system in their head at any given time. In fact, building tooling under the assumption that this is even possible or desirable seems a bit of an anti-pattern. What’s ideally required at the time of debugging is a tool that’ll help <em>reduce the search space</em>, so that engineers can zero in on a subset of dimensions (services/users/hosts etc.) that are of interest to the debugging scenario at hand. Requiring engineers to understand what happened across the <em>entire service graph</em> at the time of <em>debugging </em>an incident seems counter to the ethos of microservices architectures in the first place.</p><p id="ff2a">And yet, a traceview is <em>precisely</em> that. Admittedly, some tracing systems provide condensed traceviews when the number of spans in a trace are so exceedingly large that they cannot be displayed in a single visualization. Yet, the amount of information being encapsulated even in such pared down views still <em>squarely puts the onus on the engineers </em>to sift through all the data the <em>traceview</em> exposes and narrow down the set of culprit services. This is an endeavor machines are truly faster, more repeatable and less error-prone than humans at accomplishing.</p><p id="1208">Another reason why I’ve grown to believe that the traceview is the wrong<em> </em>abstraction is because it lends itself poorly to a hypothesis-driven debugging approach. Debugging is fundamentally an <em>iterative</em> process which involves starting with a hypothesis followed by the inspection of various observations and facts reported by the system along different axes, making deductions and testing whether the hypothesis holds water.</p><p id="3785">Being able to <em>quickly and cheaply</em> test hypotheses and refine one’s mental model accordingly is the <em>cornerstone</em> of debugging. Any tool that aims to assist in the process of debugging needs to be an <em>interactive </em>tool that helps to either whittle down the search space <em>or</em> in the case of a red herring, help the user backtrack and refocus on a different area of the system. And the ideal tool would do this <em>proactively, </em>drawing the user’s attention to potentially problematic areas.</p><p id="93e9">A <em>traceview </em>is fundamentally anything but an interactive interface. The best I can hope to do with is a traceview is be able to see <strong><em>a</em></strong> source of increased latency and view any possible tags and logs associated with it. This doesn’t help one spot <em>patterns </em>in traffic such as modes of latency distribution or provide the ability to correlate across different dimensions. <a href="https://medium.com/@Pinterest_Engineering/analyzing-distributed-trace-data-6aae58919949" rel="noopener">Aggregate analysis of traces</a> can help get around some of these problems. Indeed, there h<a href="https://engineering.salesforce.com/anomaly-detection-in-zipkin-trace-data-87c8a2ded8a1" rel="noopener nofollow">ave been reports of successful trace analysis using machine learning</a> to spot anomalous spans and identify the subset of tags that might be contributing to the anomalous behavior. However, I’m yet to see a convincing visualization of any such insights unearthed by applying machine learning or data mining on spans that’s significantly different from a traceview or a DAG.</p><h2 id="253a">Spans are too low level</h2><p id="1eed">The fundamental problem with the traceview is that a <em>span </em>is too low-level a primitive for both latency and “root cause” analysis. It’s akin to looking at individual CPU instructions to debug an exception when a much higher level entity like a backtrace would benefit day-to-day engineers the most.</p><p id="069f">Furthermore, I’d argue that what is ideally required isn’t the <em>entire picture </em>of what happened during the lifecycle of a request that modern day traces depict. What is instead required is some form of higher level abstraction of <em>what went wrong </em>(analogous to the backtrace) along with some context. Instead of seeing an entire trace, what I really want to be seeing is a <em>portion </em>of the trace where something interesting or unusual is happening. Currently, this process is entirely manual: given a trace, an engineer is required to find relevant spans to spot anything interesting. Humans eyeballing spans in individual traces in the hopes of finding suspicious behavior simply isn’t scalable, especially when they have to deal with the cognitive overhead of making sense of all the metadata encoded in all the various spans like the span ID, the RPC method name, the duration of the span, logs, tags and so forth.</p><p id="63df">Trace data is most useful when there exist incisive visualizations to surface vital insights about what’s happening in interconnected parts of a system. Until this is the case, the process of debugging remains very much <em>reactive</em>, hinging on a user’s ability to make the right correlations and inspect the right parts of the system or slice and dice across the right dimensions, as opposed to the <em>tool</em> guiding the user into formulating these hypotheses.</p><p id="602d">With the caveat that I’m not a visual designer or a UX researcher, in the following section, I want to bandy about a couple of ideas of what such visualizations might look like.</p><h2 id="a725">Service-Centric Views</h2><p id="470d">With the industry consolidating around the ideas of <a href="https://landing.google.com/sre/sre-book/chapters/service-level-objectives/" rel="noopener nofollow">SLOs and SLIs</a>, it seems reasonable that individual teams must be primarily responsible to ensure their services meet these goals. It then follows that for such teams, the best suited visualization is a <em>service-centric view</em>.</p><p id="c071">Traces, especially when unsampled, have a <em>treasure trove of information </em>about every single component of a distributed system. This data can be mined by a sophisticated trace processing engine to tease out <em>service-centric </em>insights to users. Examples of <em>service-centric </em>insights that can be surfaced upfront without requiring a user to look at traces are:</p><ol><li id="151e">latency distribution graphs of only the outlier requests</li><li id="c6b1">latency distribution graphs when the service’s SLOs aren’t met</li><li id="1f79">most “common”, “interesting” or “weird” tags in requests that are being most frequently <em>retried</em></li><li id="19aa">latency breakdowns when the service’s <em>dependencies</em> aren’t meeting their SLO</li><li id="0b26">latency breakdown by different downstream services</li></ol><p id="2692">Some of these are questions pre-aggregated metrics don’t have a prayer of answering and requiring users to pore over spans to deduce these answers results in an awfully hostile user experience.</p><p id="9478">Which then begs the question — what about complex interactions <em>between </em>various services owned by different teams, the sort that a <em>traceview </em>is considered best-suited to shine a light on?</p><p id="6688">Mobile developers, stateless service owners, owners of managed stateful services like databases and platform owners might be interested in a different <em>view</em> of the distributed system; a <em>traceview</em> is a one-size-fits-all solution to these disparate needs. Even in a very complex microservices architecture, service owners don’t need very deep knowledge of more than two or three upstream and downstream services. As a matter of fact, in most scenarios, it should be sufficient for users to answer questions pertaining to a <em>limited number of services.</em></p><p id="c023">This is not dissimilar to placing a magnifying glass on a small subgraph of services to examine them with a fine-tooth comb. This will enable the user to ask more pressing questions regarding the complex interaction between these services and their immediate dependencies. This is analogous to the backtrace in the services<em> </em>world<em>, </em>where one knows <em>what</em> is wrong as well as some context into the surrounding services’ to help deduce the <em>why.</em></p><p id="122b">The approach I’m championing here is the antithesis of a top-down traceview based approach, where one starts with an entire trace and then progressively drills down into individual spans. On the contrary, something of a bottom-up approach involves starting an investigation with one’s attention laser-focused on a small search space closer to a potential cause of an incident and then expanding the search space if needed (which might then involve enlisting the help of other teams to analyze a larger set of services). The latter approach lends itself better to the quick and dirty validation of initial hypotheses, until one has the smoking gun one needs to embark on a more focused and detailed investigation.</p><h2 id="7752">Service Topology Graphs</h2><p id="6f02">Service-centric views can be incredibly helpful once the user knows <em>which </em>service or group of services is contributing to increased latency or errors. However, in a complex system, identifying the offending service can be a non-trivial problem at the time of an incident, especially if the individual services haven’t triggered alerts.</p><p id="9038">Service topology views can be very helpful in pinpointing which service is showing a spike in error rate or increased latency leading to a user visible degradation in service quality. By a service topology view, I’m not referring to a <em>service map, </em>which depicts every single service in the system, famously used to depict <a href="https://twitter.com/adrianco/status/741739879684530176" rel="noopener nofollow">“death-star” architectures</a>. That’s no better than a DAG based <em>traceview</em>. Instead, what I’d love to see upfront are <em>dynamically generated service topology views</em> based on specific attributes like error rate or response time or even any user defined attribute, which will help the user to frame questions around specific suspect services.</p><p id="0413">To provide a more concrete example, the following is a service graph of a hypothetical newspaper webpage as implemented by a number of commercial tracing products. A frontpage service talks to Redis, a recommendation service, an ads service and a video service. The video service fetches videos from S3 and metadata from DynamoDB. The recommendations service fetches metadata from DynamoDB, data from Redis and MySQL, and writes events to Kafka. The Ads service fetches data from MySQL and writes events to Kafka.</p><p id="d635">The service graph described below depicts this topology. This can be useful if one is trying to understand service dependencies. However, in the <em>debugging</em> scenario where a specific service (say the video service) is experiencing increased response times, such a topology view isn’t particularly useful.</p><figure><div role="button" tabindex="0"><p><img alt="" src="https://miro.medium.com/max/5464/1*p7ul3420CyBWnCdo36doLQ.png" width="2732" height="2048" srcset="https://miro.medium.com/max/552/1*p7ul3420CyBWnCdo36doLQ.png 276w, https://miro.medium.com/max/1104/1*p7ul3420CyBWnCdo36doLQ.png 552w, https://miro.medium.com/max/1280/1*p7ul3420CyBWnCdo36doLQ.png 640w, https://miro.medium.com/max/1400/1*p7ul3420CyBWnCdo36doLQ.png 700w" sizes="700px" role="presentation" data-old-src="https://miro.medium.com/max/60/1*p7ul3420CyBWnCdo36doLQ.png?q=20"/></p></div><figcaption>A hypothetical service view graph of a newspaper front page.</figcaption></figure><p id="cb2e">An improvement is the diagram depicted below, which places the problem service (the video service) right at the front and center. This draws a user’s attention to this service off the bat. From this visualization, it becomes obvious that the video service is acting anomalously due to a slowdown in S3 response times, which is impacting the page load time of a portion of the frontpage.</p><figure><div><p><img alt="" src="https://miro.medium.com/max/1366/1*2P3OOVtggOSFuf5rmKLVvA.png" width="683" height="512" srcset="https://miro.medium.com/max/552/1*2P3OOVtggOSFuf5rmKLVvA.png 276w, https://miro.medium.com/max/1104/1*2P3OOVtggOSFuf5rmKLVvA.png 552w, https://miro.medium.com/max/1280/1*2P3OOVtggOSFuf5rmKLVvA.png 640w, https://miro.medium.com/max/1366/1*2P3OOVtggOSFuf5rmKLVvA.png 683w" sizes="683px" role="presentation" data-old-src="https://miro.medium.com/max/60/1*2P3OOVtggOSFuf5rmKLVvA.png?q=20"/></p></div><figcaption>A dynamic service topology graph, showing me only the “interesting” services.</figcaption></figure><p id="b4e3">Dynamically generated service topology graphs can be more powerful than static service maps, especially in elastic, auto-scaled infrastructures. Being able to compare and contrast such service topologies immediately paves the way for the user to start asking more <em>germane</em> questions. Asking better questions of the system increases the odds of the user formulating a better mental model of how the system is behaving.</p><h2 id="4981">Comparison Views</h2><p id="169c">Another useful visualization would be a comparison view. Traces currently lend themselves none too well to being juxaposed on top of each other, since then, for all intents and purposes, one is essentially comparing <em>spans</em>. And the very mainspring of this article is to hammer home the point that spans are too low-level to meaningfully be able to unearth the most valuable insights from trace data.</p><p id="f732">Comparing two traces doesn’t require groundbreaking new visualizations. As a matter of fact, something like a stacked bar chart showing the same data that a traceview depicts can be surprisingly more insightful than having to look at two individual traces separately. Even more powerful would be the ability to <em>visualize</em> the comparison of traces <em>in aggregate. </em>It’d be enormously useful to see how a newly deployed GC configuration change of a database impacts the response time of a downstream service over the course of a few hours. If what I’m describing here sounds like A/B testing the impact of infrastructural changes <em>across multiple services </em>with the help of trace data, then that wouldn’t too far off the mark.</p><p id="b22d">I’m not questioning the utility of tracing data itself. I truly believe there’s no other observability signal that is pregnant with data more rich, causal and contextual than that carried by a trace. However, I also believe that this data is woefully underutilized by every last tracing solution out there. As long as tracing products cleave to the traceview in any way, shape or form, they will be limited in their ability to truly leverage the invaluabe information that can be extracted from trace data. Moreover, this runs the risk of propping up a very user-unfriendly and unintuitive visual interface, effectively stymieing the user’s ability to debug more effectively.</p><p id="602b">Debugging complex systems, even with the state-of-the-art tooling, is incredibly hard. Tools need to strive to assist a developer in the process of forming and validating a hypothesis by <strong>proactively surfacing</strong> relevant information, outliers and latency distribution characteristics. For tracing to become the tool developers and operators reach for immediately when debugging a production incident or customer issue that spans multiple services, what is required is novel user interfaces and visualizations that correspond more closely to the mental model of developers building and operating these services.</p><p id="28b7">It will take an enormous amount of careful thought to design a system that will layer different signals available in trace data in a manner optimized for easy exploration and deduction. There needs to be thought put into how the system’s topology at the time of debugging can be abstracted in a way that helps a user in getting over their blind spots without the user ever having to look at an individual trace or a span.</p><p id="c79d">What we need is good abstractions and layering, especially in the UI, the sort that can lend itself well toward hypothesis driven debugging, where one can iteratively ask questions and validate conjectures. While this isn’t going to automatically solve every last observability problem, it can greatly help users hone their sense of intuition and enable them to ask better questions. What I’m calling for is more thought and innovation to happen on the visualization front. There’s a real opportunity to push the envelope.</p></div></div>