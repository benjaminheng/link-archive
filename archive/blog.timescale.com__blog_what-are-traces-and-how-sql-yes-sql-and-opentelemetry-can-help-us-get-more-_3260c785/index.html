---
url: https://blog.timescale.com/blog/what-are-traces-and-how-sql-yes-sql-and-opentelemetry-can-help-us-get-more-value-out-of-traces-to-build-better-software/
title: What are traces, and how SQL (yes, SQL) and OpenTelemetry can help us get more
  value out of traces to build better software
archived_at: 2021-12-13T16:09:22.856802+08:00
---
<div id="readability-page-1" class="page"><div>
        <p><strong><em>Promscale, the observability backend powered by SQL, now includes support for collecting traces via OpenTelemetry in beta.</em></strong><br/></p><p>Developing software is hard. Debugging complex software systems is often harder. When our software systems are not healthy, we need ways to quickly identify what is happening, and then dig deeper to understand why it is happening (and then fix the underlying issues). But in modern architectures based on microservices, Kubernetes and cloud, identifying problems (let alone predicting them) has become more and more difficult. </p><p>Enter observability, built on the collection of telemetry from modern software systems. This telemetry typically comes in the form of three signals: metrics, logs, and traces. </p><p>Metrics and logs are well known and have been widely adopted for many years through tools like <a href="https://www.nagios.org/">Nagios</a>, <a href="https://prometheus.io/">Prometheus</a>, or the <a href="https://www.elastic.co/what-is/elk-stack">ELK</a> stack.</p><p>Traces, on the other hand, are relatively new and have seen much lower adoption. Why? Because, for most engineers, tracing is still a relatively new concept. Because getting started takes a lot of manual instrumentation work. And because, once we have done that work, <a href="https://danluu.com/tracing-analytics/">getting value out of trace data</a> is hard (for example, most tracing tools today just provide the ability to look up a trace by id or apply very simple filtering like Jaeger or Grafana Tempo).</p><p>However, traces are key to understanding the behavior of and troubleshooting modern architectures. </p><p>Here we demystify traces and explain what they are, and why they are useful, using a concrete example. Then we describe OpenTelemetry and explain how it vastly simplifies the manual instrumentation work required to generate traces.</p><p>Finally, we announce the beta release of trace support in Promscale, the observability backend powered by SQL, via OpenTelemetry, and describe how Promscale and SQL enable us to get much more value out of trace data. </p><p>Read on for more. If you‚Äôd like to get started with Promscale right away:</p><ul><li><a href="https://github.com/timescale/promscale#readme"><strong>Install the latest version of Promscale</strong></a>, following the instructions in our <a href="https://github.com/timescale/promscale#readme">GitHub repository</a> (appreciate any GitHub stars!). As a reminder, Promscale is open-source and completely free to use.</li><li><a href="https://slack.timescale.com/"><strong>Join the TimescaleDB Slack community</strong></a>, where you‚Äôll find 7K+ developers and Timescale engineers active in all channels. (The dedicated #promscale channel has 2.9K+ members, so it‚Äôs a great place to connect with like-minded community members, ask questions, get advice, and more).</li></ul><p>If you would like to connect with us, catch our talks at <a href="https://www.timescale.com/promcon">PromCon North America</a>. We are also at <a href="https://events.linuxfoundation.org/kubecon-cloudnativecon-north-america/">KubeCon+CloudNativeCon North America</a> üéâ Come to say hi to the Timescale booth (#S76)<strong> </strong>or join the Timescale virtual booth to chat with Promscale engineers, see Promscale in action during Office Hours session (Oct 14, 10:30 am PDT), and get cool swag!</p><h2 id="what-is-a-trace">What is a trace?</h2><p>A ‚Äútrace‚Äù represents how an individual request flows through the various microservices in a distributed system. A ‚Äúspan‚Äù is the fundamental building block of a trace, representing a single operation. In other words, a trace is a collection of underlying spans.</p><p>Let‚Äôs look at a specific example to illustrate the concept.</p><p>Imagine that we have a news site that is made of four micro-services:</p><ul><li>The<strong> </strong><em><strong>frontend</strong></em><strong> service</strong>, which serves the website to our customer‚Äôs browser.</li><li>The<strong> </strong><em><strong>news</strong></em><strong> service</strong>, which provides the list of articles from our news database that is populated by the editorial system (and has the ability to search articles and get individual articles together with their comments).</li><li>The<strong> </strong><em><strong>comment</strong></em><strong> service</strong>, which lets you save new comments in the comment database and retrieve all comments for an article.</li><li>The<strong> <em>advertising</em> service</strong>, which returns a list of ads to display from a third-party provider.</li></ul><figure><img src="https://blog.timescale.com/content/images/2021/10/what-is-a-trace--1-.jpg" alt="An architecture diagram for an example newsite made up of four microservices: a frontend service, a news service, a comment service and an advertising service." loading="lazy" width="1864" height="1094" srcset="https://blog.timescale.com/content/images/size/w600/2021/10/what-is-a-trace--1-.jpg 600w, https://blog.timescale.com/content/images/size/w1000/2021/10/what-is-a-trace--1-.jpg 1000w, https://blog.timescale.com/content/images/size/w1600/2021/10/what-is-a-trace--1-.jpg 1600w, https://blog.timescale.com/content/images/2021/10/what-is-a-trace--1-.jpg 1864w" sizes="(min-width: 720px) 720px"/><figcaption>An architecture diagram for an example news site made up of four microservices: a frontend service, a news service, a comment service, and an advertising service.</figcaption></figure><p>When a user clicks on the link to view an article on her browser this is what happens:</p><p>1) The <em>frontend</em> service receives the request.</p><p>2) The <em>frontend</em> service calls the <em>news</em> service passing the identifier for the article.</p><p>3) The <em>news</em> service calls the news database to retrieve the article.</p><p>4) The <em>news</em> service calls the <em>comment</em> service to retrieve the comments for the 	article.</p><p>5) The <em>comment</em> service calls the comment database and runs a query to retrieve all comments for the article.</p><p>6) The <em>news</em> service gets all comments for the article and sends the article and the comments back to the <em>frontend</em> service.</p><p>7) The <em>frontend</em> service calls the <em>advertising</em> service passing the contents of the article.</p><p>8) The <em>advertising</em> service makes a REST API request to the third-party ads provider with the contents of the article to retrieve the list of optimized ads to display.</p><p>9) The <em>frontend</em> service builds the HTML page including the news, the comments and the ads send the response back to the user‚Äôs browser.</p><p>When adding trace instrumentation to each of those services, you generate spans for each operation in the execution of the request outlined above (and more if you want more detailed tracking). This would result in a hierarchy of spans like shown in the diagram below:</p><figure><img src="https://blog.timescale.com/content/images/2021/10/hierarchy-of-spans--1-.jpg" alt="Diagram illustrating the hierarchy of spans for the news microservices" loading="lazy" width="2000" height="1460" srcset="https://blog.timescale.com/content/images/size/w600/2021/10/hierarchy-of-spans--1-.jpg 600w, https://blog.timescale.com/content/images/size/w1000/2021/10/hierarchy-of-spans--1-.jpg 1000w, https://blog.timescale.com/content/images/size/w1600/2021/10/hierarchy-of-spans--1-.jpg 1600w, https://blog.timescale.com/content/images/size/w2400/2021/10/hierarchy-of-spans--1-.jpg 2400w" sizes="(min-width: 720px) 720px"/><figcaption>Hierarchy of spans for the news site microservice architecture. The length of each span indicates their duration.</figcaption></figure><p>The entry point for the request is the <em>frontend</em> service. The first span the <em>frontend</em> service emits covers the entire execution of the request. That span is called the root span. All other spans are descendants of that root span. The length of each span indicates their duration.</p><h3 id="what-do-traces-show">What do traces show?</h3><p>As you can see from the diagram above there are two key pieces of information we can extract from a trace:</p><ol><li>A connected representation of all the steps to process individual requests which very easily allow us to zero-in on the service and operation that is causing issues in your system when troubleshooting a production problem.</li><li>The dependencies between different components in the system which we could use to build a map of how those components connect to each other. In a large system with tens or hundreds of components it is important to explore and understand the topology of the system to identify problems and improvements.</li></ol><h3 id="faster-troubleshooting-with-traces">Faster troubleshooting with traces</h3><p>Let‚Äôs see through a practical example of how traces help identify problems in your applications faster.</p><p>Continuing with our example, imagine that less than 1% of the REST API requests to the ads provider are suffering from slow response time (30 seconds). But those requests always come from the same set of users who are complaining to your support team and on Twitter. </p><p>We look into the problem but aggregate percentile metrics (see our blog post on <a href="https://blog.timescale.com/blog/how-percentile-approximation-works-and-why-its-more-useful-than-averages/">percentile metrics</a> to learn how to use them) are not indicating any problem because overall performance (99th percentile of response time, p99 for short) is great since this only impacts a small number of requests. </p><p>Then we start looking into our logs but that‚Äôs a daunting task. We have to look at logs for each individual service and there are concurrent requests that make it very hard to read and connect those logs to identify the problem. </p><p><strong>What we need is to reconstruct requests around the time users reported the issue, find the requests that were slow, and then determine where that slowness happened.</strong></p><p>With logs, we have to do that manually which for a high traffic site it would take hours to do.</p><p>With traces, we can do that automatically and quickly identify where the problem is.</p><p>One simple way to do it is to search for the slowest traces, that is, top ten root spans with the highest duration during the time the users complained and look at what‚Äôs consuming most of the execution time. In our example, by looking at the visual trace representation we would very quickly see that what‚Äôs common in the slowest traces is that the request to the ads provider REST API is taking too long. An even better way (if your tracing system allows for that) would be to run a query to retrieve the slowest spans in the execution path of the slowest traces which would return the spans tracking the REST API calls.</p><p>Note that looking at the p99 response time of those REST API calls would not have revealed any problem either because the problem occurred in less than 1% of those requests.</p><p>We‚Äôve quickly narrowed down where the problem is and can start looking for a solution as well as inform the ads provider of the issue so they can investigate it. </p><p>One quick fix could be to put in place a one-second timeout in the API request so that a problem with the ads provider doesn‚Äôt impact your users. Another more sophisticated solution could be to make ads rendering an asynchronous call so it doesn‚Äôt impact rendering the article.</p><h3 id="traces-help-us-proactively-make-software-better">Traces help us proactively make software better</h3><p>We can also use traces to proactively make our software better. For example, we could search for the slowest spans that represent database requests to identify queries to optimize. We could search for requests (i.e., traces) that involve a high number of services, or many database calls, or too many external service calls, and look for ways to optimize them and/or simplify the architecture of the system.</p><h3 id="recap">Recap</h3><p>We have seen how traces are useful to troubleshoot problems in microservices environments faster and discover improvements that we could implement to help us build better software that delights our customers.</p><p>So what‚Äôs needed to get the benefits that traces provide? A tool to instrument services to generate traces, and a system to store, query and visualize them. </p><p>Continue reading to learn how OpenTelemetry makes instrumentation easier, and how Promscale and SQL enable us to get more value out of traces, faster.</p><h2 id="traces-in-opentelemetry">Traces in OpenTelemetry</h2><p><a href="https://opentelemetry.io/">OpenTelemetry</a> is a vendor-agnostic emerging standard to instrument and collect traces (and also metrics and logs!) that can then be sent to and analyzed in any OpenTelemetry compatible backend. It has recently been <a href="https://www.cncf.io/blog/2021/08/26/opentelemetry-becomes-a-cncf-incubating-project/">accepted as a CNCF incubating project</a> and it has a lot of momentum: it‚Äôs <a href="https://all.devstats.cncf.io/d/74/contributions-chart?orgId=1">the second most active CNCF project</a>, only after Kubernetes, with contributions from <a href="https://opentelemetry.devstats.cncf.io/d/5/companies-table?orgId=1&amp;var-period_name=Last%20year&amp;var-metric=contributions">all major observability vendors, cloud providers, and many end users</a> (including Timescale).</p><p>OpenTelemetry includes a number of core components:</p><ul><li><strong>API specification</strong>: defines how to produce telemetry data in the form of traces, metrics, and logs.</li><li><strong>Semantic conventions</strong>: defines a set of recommendations to standardize the information to include in the telemetry (for example attributes like the status code of a span representing an http request) and ensure better compatibility between systems.</li><li><strong>OpenTelemetry protocol (OTLP)</strong>: defines a standard encoding, transport, and delivery mechanism of telemetry data between the different components of an observability stack: telemetry sources, collectors, backends, etc.</li><li><strong>SDKs</strong>: language-specific implementations of the OpenTelemetry API with additional capabilities like processing and exporting for traces, metrics and logs.</li><li><strong>Instrumentation libraries</strong>: language-specific libraries that provide instrumentation for other libraries. All instrumentation libraries support manual instrumentation and several offer automatic instrumentation through byte-code injection.</li><li><strong>Collector</strong>: this component provides the ability to receive telemetry from a wide variety of sources and formats, process it and export it to a number of different backends. It eliminates the need to manage multiple agents and collectors.</li></ul><figure><img src="https://blog.timescale.com/content/images/2021/10/opentelemetry-collector--1-.jpg" alt="Architecture diagram illustrating the inputs, internal processing and outputs of the OpenTelemetry collector." loading="lazy" width="2000" height="1097" srcset="https://blog.timescale.com/content/images/size/w600/2021/10/opentelemetry-collector--1-.jpg 600w, https://blog.timescale.com/content/images/size/w1000/2021/10/opentelemetry-collector--1-.jpg 1000w, https://blog.timescale.com/content/images/size/w1600/2021/10/opentelemetry-collector--1-.jpg 1600w, https://blog.timescale.com/content/images/size/w2400/2021/10/opentelemetry-collector--1-.jpg 2400w" sizes="(min-width: 720px) 720px"/><figcaption>An architecture diagram illustrating the core components of the OpenTelemetry collector, the inputs it accepts and possible outputs it can produce.</figcaption></figure><p>To collect traces from our code with OpenTelemetry we will use the SDKs and instrumentation libraries for the language your services are written in. Instrumentation libraries make OpenTelemetry easy to adopt because they can auto-instrument (yes, auto-instrument!) our code for services written in languages that allow for injecting instrumentation at runtime like Java and Node.js. </p><p>For example, the OpenTelemetry Java instrumentation library automatically collects traces from a <a href="https://github.com/open-telemetry/opentelemetry-java-instrumentation/blob/main/docs/supported-libraries.md#libraries--frameworks">large number of libraries and frameworks</a>. For languages where that is not possible (like Go) we also get libraries that simplify the instrumentation but require more changes to the code.</p><p>Even more, developers of libraries and components are already adding OpenTelemetry instrumentation directly in their code. Two examples of that are <a href="https://kubernetes.io/docs/concepts/cluster-administration/system-traces/">Kubernetes</a> and <a href="https://www.apollographql.com/docs/federation/opentelemetry/">GraphQL Apollo Server</a>.</p><p>Once our code is instrumented we have to configure the SDK to export the data to an observability backend. While we can send the data directly from our application to a backend, it is more common to send the data to the OpenTelemetry Collector and then have it send the data to one or multiple backends. This way you can simplify the management and configuration of where you want to send the data and have the possibility to do additional processing (downsampling, dropping, transforming data) before it is sent to another system for analysis.</p><h3 id="anatomy-of-an-opentelemetry-trace">Anatomy of an OpenTelemetry trace</h3><p>The <a href="https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/overview.md#tracing-signal">OpenTelemetry tracing specification</a> defines the data model for a trace. Technically, a trace is a <a href="https://en.wikipedia.org/wiki/Directed_acyclic_graph">directed acyclic graph</a> of Spans with parent-child relationships. Traces must include an operation name, start and finish timestamps, a parent Span identifier and the SpanContext. The SpanContext contains the TraceId, the SpanID, TraceFlags and the Tracestate. Optionally, Spans can also have a list of Events, Links to other related Spans and a set of Attributes (key-value pairs). Events are typically used to add to a Span one-time events like errors (error message, stacktrace and error code) or log lines that were recorded during the span execution. Links are less common but allow OpenTelemetry to support special scenarios like relating spans that are included in a batch operation with the batch operation span which would be initiated by multiple parents (i.e., all the individual spans that add elements to the batch).</p><p>Attributes can contain any key-value pair. <a href="https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/trace/semantic_conventions/README.md">Trace semantic conventions</a> define some mandatory and optional attributes to help with interoperability. For example, a span representing the client or server of an <a href="https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/trace/semantic_conventions/http.md#common-attributes">HTTP request</a> must have an http.method attribute and may have http.url and http.host attributes.<br/></p><figure><img src="https://blog.timescale.com/content/images/2021/10/opentelemetry-span-diagram--1-.jpg" alt="Data model of an OpenTelemetry Span" loading="lazy" width="2000" height="544" srcset="https://blog.timescale.com/content/images/size/w600/2021/10/opentelemetry-span-diagram--1-.jpg 600w, https://blog.timescale.com/content/images/size/w1000/2021/10/opentelemetry-span-diagram--1-.jpg 1000w, https://blog.timescale.com/content/images/size/w1600/2021/10/opentelemetry-span-diagram--1-.jpg 1600w, https://blog.timescale.com/content/images/size/w2400/2021/10/opentelemetry-span-diagram--1-.jpg 2400w" sizes="(min-width: 720px) 720px"/><figcaption>Data model of an OpenTelemetry Span</figcaption></figure><h3 id="recap-1">Recap</h3><p>OpenTelemetry is a new vendor-agnostic standard that makes trace instrumentation and collection much easier through automation, SDKs and a protocol to provide interoperability with observability tools.</p><h2 id="analyzing-traces-with-sql">Analyzing traces with SQL</h2><p>Above, we talked about several ways to get value out of traces. For example, when debugging our news application, searching for the top 10 root spans with the highest duration during the time that users complained. Or, when trying to proactively improve our news application, to search for the slowest spans that represent database requests to identify queries to optimize. Or similarly, to search for requests (i.e. traces) that involve a high number of services, or many database calls, or too many external service calls, and look for ways to optimize them and/or simplify the architecture of the system.</p><p>Yet there is no standard way to analyze trace data to ask these questions. In the past, a small number of organizations (e.g., Google, Twitter, Uber, etc.) have built their own systems to do deeper analysis on their trace data. There have also been a number of open-source efforts (e.g., Jaeger, Zipkin, Grafana Tempo) which provide a UI that is very helpful to find and visualize individual traces but don‚Äôt provide the flexibility of a language to run any query and aggregate traces as needed to derive new insights.</p><p>Turns out that we already have a universal query language for data analysis, one that most developers (and many non-developers) already know: SQL. </p><p>In fact, with SQL, we can interrogate our trace data to answer any question we need to answer, in a way not possible with existing open-source tracing tools like Jaeger and Grafana Tempo.</p><p>For example:</p><ul><li>List the operations with the highest error rates.</li><li>List the slowest API methods.</li><li>List the slowest database queries across all services.</li><li>Identify customers suffering from the worst database query performance and how it compares to performance across all customers.</li><li>Identify the upstream service causing the load on a service that is seeing elevated load.</li></ul><p>Even more, with SQL you could correlate traces and metrics at query time. For example, you could show response time per service correlated with CPU and memory consumption per service if you have container metrics in the same database.</p><p>But of course, before we can use SQL to query traces (and metrics), we need to be able to store those traces in a scalable system that supports SQL, yet is designed for observability.</p><p>Enter Promscale.</p><h2 id="promscale-is-the-observability-backend-powered-by-sql">Promscale is the observability backend powered by SQL</h2><p>Promscale was first announced <a href="https://blog.timescale.com/blog/promscale-analytical-platform-long-term-store-for-prometheus-combined-sql-promql-postgresql/">one year ago</a> as an analytical platform for Prometheus metrics. Promscale is built on the solid foundation of TimescaleDB and PostgreSQL, and therefore has full SQL support <a href="https://www.timescale.com/promscale">(along with many other neat features</a> like 100% PromQL compliance). Today, companies like Digital Ocean, Electronic Arts and Catalytic rely on Promscale to scale Prometheus to do long-term retention and analysis on their metrics.</p><p>Our vision for Promscale is to enable engineers to store all observability data (metrics, logs, traces, metadata, and other future data types) in a single mature and scalable store and analyze it through a unified and complete SQL interface that provides developers with:</p><ul><li>Broad support for observability standards (e.g., OpenTelemetry, Prometheus/PromQL, StatsD, Jaeger, Zipkin, etc.) to simplify integration in any environment.</li><li>Operational simplicity with just one storage system that is easy to deploy, manage, scale, and learn about.</li><li>A familiar experience with PostgreSQL as the foundation and unified access to all data via full SQL support so they don‚Äôt need to learn other query languages.</li><li>Unparalleled insights through the power of TimescaleDB‚Äôs advanced time-series analytical functions and Postgres‚Äô SQL query capabilities (joins, sub-queries, etc.) to analyze and correlate observability <em>and</em> business data.</li><li>100s of out-of-the-box integrations through the PostgreSQL ecosystem: visualization tools, IDEs, ORMs, management tools, performance tuning, etc.</li></ul><p>Today we are announcing the beta release of trace support in Promscale, our second major step in fulfilling our vision.</p><p>Promscale exposes an ingest endpoint that is OTLP-compliant which makes integration with OpenTelemetry instrumentation straightforward. Other tracing formats like Jaeger, Zipkin or OpenCensus can also be sent to Promscale through the OpenTelemetry Collector. Traces stored in Promscale can be queried with full SQL and visualized using Jaeger or Grafana.</p><figure><img src="https://blog.timescale.com/content/images/2021/10/Picture1--2-.png" alt="Architecture diagram illustrating Promscale architecture, with inputs from Prometheus metrics and OpenTelemetry traces, TimescaleDB as the core database powering Promscale and outputs to a variety of tools including Jaeger and Grafana." loading="lazy" width="936" height="368" srcset="https://blog.timescale.com/content/images/size/w600/2021/10/Picture1--2-.png 600w, https://blog.timescale.com/content/images/2021/10/Picture1--2-.png 936w" sizes="(min-width: 720px) 720px"/><figcaption>Architecture diagram illustrating Promscale architecture, with inputs from Prometheus metrics and OpenTelemetry traces, TimescaleDB as the core database powering Promscale and outputs to a variety of tools including Jaeger and Grafana.</figcaption></figure><h3 id="designing-an-optimized-schema-for-traces">Designing an optimized schema for traces</h3><p><br/>Promscale stores OpenTelemetry traces using the following schema:</p><figure><img src="https://blog.timescale.com/content/images/2021/10/promscale-schema--1-.jpg" alt=" Promscale schema for traces" loading="lazy" width="2000" height="1409" srcset="https://blog.timescale.com/content/images/size/w600/2021/10/promscale-schema--1-.jpg 600w, https://blog.timescale.com/content/images/size/w1000/2021/10/promscale-schema--1-.jpg 1000w, https://blog.timescale.com/content/images/size/w1600/2021/10/promscale-schema--1-.jpg 1600w, https://blog.timescale.com/content/images/2021/10/promscale-schema--1-.jpg 2090w" sizes="(min-width: 720px) 720px"/><figcaption>Promscale schema for traces</figcaption></figure><p>The schema is heavily influenced by the OpenTelemetry <a href="https://github.com/open-telemetry/opentelemetry-proto/blob/main/opentelemetry/proto/trace/v1/trace.proto">protocol buffer definitions</a>.</p><p>The heart of the model is the span table. The span table is a <a href="https://docs.timescale.com/timescaledb/latest/getting-started/create-hypertable/#chunks-and-hypertables">hypertable</a>, using the power of TimescaleDB to manage the ingestion and querying of spans over time. Similarly, both links and events are hypertables. Link tables use the start time of the source span, whereas each event has its own associated time.</p><p>The span table is self-referencing. All the spans in a given trace form a tree. The span table uses the adjacency model to capture these trees - each span contains the id of the span‚Äôs parent. The root span of each trace has a <code>parent_span_id</code> of 0. The OpenTelemetry protocol buffers already utilize an adjacency model to represent the tree structure, so keeping this same model at the database layer makes ingestion easier. Other models such as the path enumeration model can be derived from an adjacency model, and we do this in several convenience functions.</p><p>Spans, links, events, and resources can all be decorated with zero or more <a href="https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/common/common.md#attributes">attributes</a>. Attributes are key-value pairs in which the key is a text name, and the value can be a primitive type (string, boolean, double, or 64 bit integer), or a homogeneous array.</p><p>We have chosen to use ‚Äútag‚Äù instead of ‚Äúattribute‚Äù in our model. ‚ÄúAttribute‚Äù gets to be a real pain to type over and over and over, and by our estimation ‚Äútag‚Äù is more widely used and understood in the industry.</p><p>Tag values map very closely to json, and therefore we have chosen to store tag values in the <a href="https://www.postgresql.org/docs/13/datatype-json.html">jsonb data type</a>. PostgreSQL has extensive support for storing and <a href="https://www.postgresql.org/docs/13/functions-json.html">manipulating</a> jsonb values, including <a href="https://www.postgresql.org/docs/13/datatype-json.html#JSON-INDEXING">indexing</a> and <a href="https://www.postgresql.org/docs/13/functions-json.html#FUNCTIONS-SQLJSON-PATH">jsonpath querying</a>. By using jsonb, we can piggy-back on PostgreSQL‚Äôs features to provide rich ways of filtering spans that in many cases will be indexed operations.</p><p>Many tags will be repeated again and again across many spans. For this reason, we are not storing tags directly in the span table, but normalizing them out into <code>tag_key</code> and tag tables. This eliminates data duplication and greatly reduces the storage required for the span table.</p><p>Traditionally, a many-to-many relationship between spans and tags would be represented with an additional mapping table. We decided to eschew this approach. An additional mapping table would have considerably more records than the span table itself. It would need to contain both the <code>trace_id</code> and <code>span_id</code> which are 128 bits and 64 bits respectively, a timestamptz (it would need to be a hypertable in its own right), and the 64 bit ids of the tag and <code>tag_key</code>. This would require significant additional storage.</p><p>Instead of this mapping table, we created a domain over jsonb called a ‚Äútag_map‚Äù. A <code>tag_map</code> is a json object where keys are the ids of the <code>tag_key</code> table, and the associated values are ids of the tag table. Thus, the <code>tag_map</code> is a set of key-value pairs of <code>tag_keys</code> to tag values. We have thus essentially collapsed the mapping table into the span table.</p><p>The tag table may in some setups become quite large. We have utilized PostgreSQL‚Äôs <a href="https://www.postgresql.org/docs/13/ddl-partitioning.html">declarative partitioning</a> to hash partition the tag table on the key text over 64 partitions. This effectively ‚Äúload balances‚Äù the tag values over many smaller tables rather than storing them all in one big table. By hash partitioning on key text, all the values for a given key will be colocated in the same partition, and thereby belong to the same partition-level indexes, improving performance. Partitioning the tags should also provide some resiliency, in that operations on one key should not impact all keys. The number 64 was chosen more or less randomly. We intend to do some testing to find an optimal number of partitions.</p><p>We are sharing how our schema works to help other developers in the community looking at solving a similar problem. Knowing the design of the underlying schema can also be helpful in situations where you may need to improve the performance of some query. However, you don‚Äôt really need (and we don‚Äôt expect you!) to understand how our schema works because Promscale comes with out-of-the-box views, functions and operators that make querying the data easier and faster that we cover in the next section.</p><h3 id="querying-traces-using-sql">Querying Traces using SQL</h3><p>Promscale provides unified access to all your traces and metrics through a single, robust and well-known query language: SQL. Thanks to the power of SQL, the out-of-the-box views, functions and operators built-in in Promscale and the time-series analytical functions provided by TimescaleDB you can interrogate your data about pretty much any question you need to answer.</p><p>Everything you need to query traces is in the <code>ps_trace</code> database schema:</p><ul><li>3 views: span, event and link. Those views automatically join the different tables in the schema to provide a consolidated view of a span, an event or a link as if all attributes were stored in the same table.</li><li>A number of operators so you can easily apply conditions to resource, span, link and event attributes (we call those attributes tags in our data model).</li><li>Functions to easily navigate through and retrieve tag values.<br/></li></ul><p>To understand how to query traces we will use some of the examples we listed at the beginning of this section. The data we use in the examples comes from a Kubernetes cluster running <a href="https://github.com/honeycombio/microservices-demo">Honeycomb‚Äôs fork</a> of <a href="https://github.com/GoogleCloudPlatform/microservices-demo">Google‚Äôs microservices demo</a> that uses OpenTelemetry instrumentation.</p><p>In the examples below we show the raw results from the SQL queries. Those results can be easily displayed in Grafana dashboards by connecting to the underlying TimescaleDB/PostgreSQL database using Grafana‚Äôs PostgreSQL datasource:</p><figure><img src="https://blog.timescale.com/content/images/2021/10/Grafana-dashboard-tracing-sql-1.png" alt="Grafana dashboard showing performance metrics from querying traces in Promscale with SQL" loading="lazy" width="2000" height="1197" srcset="https://blog.timescale.com/content/images/size/w600/2021/10/Grafana-dashboard-tracing-sql-1.png 600w, https://blog.timescale.com/content/images/size/w1000/2021/10/Grafana-dashboard-tracing-sql-1.png 1000w, https://blog.timescale.com/content/images/size/w1600/2021/10/Grafana-dashboard-tracing-sql-1.png 1600w, https://blog.timescale.com/content/images/size/w2400/2021/10/Grafana-dashboard-tracing-sql-1.png 2400w" sizes="(min-width: 720px) 720px"/><figcaption>Grafana dashboard showing performance metrics from querying traces in Promscale with SQL</figcaption></figure><p><strong>Query 1: ¬†List the top operations with the highest error rate in the last hour</strong></p><p>Response time, throughput and error rate are the key metrics used to assess the health of a service. In particular, high error rate and response time are key indicators of the experience we are delivering to our users and need to be tracked closely. In this example, we look at how we can use OpenTelemetry traces and SQL to identify the main sources of errors in our services.</p><p>Every span has an attribute that indicates the name of the service (<em>service_name</em>) and an attribute that indicates the name of the operation (<em>name</em>). Technically, the service name in OpenTelemetry is not a span attribute but a resource attribute. For the purposes of querying traces in Promscale we can think of service name as a span attribute as well.</p><p>Every span has another attribute that indicates whether the span resulted in an error or not: <code>status_code</code>. If there is an error, the value of <code>status_code</code> is <code>STATUS_CODE_ERROR</code>.</p><p>Our goal is to write a query that will return one row per individual operation with the total number of executions (number of spans), total number of executions that led to an error (spans where the status code is an error) and the percentage of spans with an error for the top 10 operations with more errors:</p><pre><code>SELECT
    service_name,
    span_name as operation,
    COUNT(*) FILTER (WHERE status_code = &#39;STATUS_CODE_ERROR&#39;) as spans_with_error,
    COUNT(*) as total_spans,
    TO_CHAR(100*(CAST(COUNT(*) FILTER (WHERE status_code = &#39;STATUS_CODE_ERROR&#39;) AS float) / count(*)), &#39;999D999%&#39;) as error_rate
FROM span
WHERE
     start_time &gt; NOW() - INTERVAL &#39;1 hour&#39;
GROUP BY service_name, operation
ORDER BY error_rate DESC
LIMIT 10;
</code></pre>
<p>As you can see, the query uses the standard SQL syntax we are all familiar with: <code>SELECT</code>, <code>FROM</code>, <code>WHERE</code>, <code>GROUP BY</code>, <code>ORDER BY</code>.</p><p>In the <code>SELECT</code> clause we project the service name and the operation (which corresponds to the span name). These are also the two attributes we use to aggregate the results in the <code>GROUP BY</code> clause.</p><p>The other three columns we project are the number of spans with an error, the total number of spans and the error rate within each error group. To do it we use some nifty SQL capabilities available in PostgreSQL:</p><ul><li><code>COUNT (*)</code> which returns the total number of rows, spans in this case, in a group.</li><li><code>COUNT (*) FILTER</code> which returns the total number of spans in a group matching a certain criteria. In our case we want spans with an error which are indicated by the value <code>STATUS_CODE_ERROR</code> in the <code>status_code</code> attribute.</li><li><code>CAST</code> to convert the number of spans with error to a floating point number so when it‚Äôs divided by the total count of spans it returns a floating number and not an integer. If we don‚Äôt do this then the number will be converted to the closest integer which will be 0 since that division is always less than 0.</li><li><code>TO_CHAR</code> to convert the error rate to an easy to read and understand percentage number.</li></ul><p>Below is an example of results from this query:</p><pre><code> service_name |             operation             | spans_with_error | total_spans | error_rate
--------------+-----------------------------------+------------------+-------------+------------
 frontend     | /cart/checkout                    |               12 |         345 |    3.478%
 frontend     | hipstershop.AdService/GetAds      |               60 |        5214 |    1.115%
 adservice    | hipstershop.AdService/GetAds      |                1 |        5214 |     .019%
 cart         | grpc.health.v1.Health/Check       |                0 |         707 |     .000%
 cart         | hipstershop.CartService/EmptyCart |                0 |         345 |     .000%
 cart         | hipstershop.CartService/GetCart   |                0 |        7533 |     .000%
 checkout     | SQL SELECT                        |                0 |         361 |     .000%
 checkout     | grpc.health.v1.Health/Check       |                0 |         718 |     .000%
 checkout     | getDiscounts                      |                0 |         345 |     .000%
 checkout     | hipstershop.CartService/EmptyCart |                0 |         345 |     .000%
</code></pre>
<p>Which immediately indicates that we need to take a closer look at the code behind the <em>/cart/checkout</em> operation since it has a very high error rate most likely leading to many lost sales!</p><p>Another thing that drives our attention in these results are the second and third rows. What‚Äôs surprising about them is that the error rate on the client side of the request <em>(frontend - hipstershop.AdService/GetAds</em>) is much higher than the error rate on the server side of the same request (<em>adservice - hipstershop.AdService/GetAds</em>). So the adservice is successfully completing the request but something is happening when transferring the response back to the frontend service.</p><p>Before we move on to the next example, let‚Äôs look at a different way to write the query that leverages additional SQL capabilities. To calculate the error rate in the query above we are using twice the functions required to count spans with error and total spans. This can lead to inconsistencies if we update the query to change the way we calculate the error rate but don‚Äôt apply those changes everywhere. To avoid that we can use SQL subqueries:</p><pre><code>SELECT
  service_name,
  operation,
  spans_with_error,
  total_spans,
  TO_CHAR(100*(CAST(spans_with_error AS float)) / total_spans, &#39;999D999%&#39;) as error_rate
FROM (
    SELECT
        service_name,
        span_name as operation,
        COUNT(*) FILTER (WHERE status_code = &#39;STATUS_CODE_ERROR&#39;) as spans_with_error,
        COUNT(*) as total_spans
    FROM span
    WHERE
        start_time &gt; NOW() - INTERVAL &#39;1 hour&#39;
    GROUP BY service_name, operation
) AS error_summary
ORDER BY error_rate DESC
LIMIT 10;
</code></pre>
<p>This query first builds a dataset (<code>error_summary</code>) with service name, operation, spans with error and total spans and then it uses the values calculated in that dataset to compute the error rate avoiding the duplication in the initial query. This change doesn‚Äôt impact the performance of the query.</p><p>This is a straightforward example of what you can do with subqueries. SQL subqueries provide a lot of flexibility for analyzing your traces to derive new insights.</p><p>An additional consideration is that the query searches across all spans and depending on the environment and the amount of instrumentation you could see some duplicative results because of parent-child relationships between spans. In those cases it could be better to start by looking at traces (complete request) that had an error. You can do that by only searching across root spans by adding an additional condition to the where clause:</p><pre><code>WHERE start_time &gt; NOW() - INTERVAL &#39;1 hour&#39; AND parent_span_id = 0
</code></pre>
<p><strong>Query 2: List the top slowest operations in the last hour</strong></p><p>At the beginning of the previous example we identified response time and error rate as two key indicators of the experience we deliver to our users. Let‚Äôs see now how we can quickly determine bottlenecks in our services.</p><p>All spans contain a duration attribute that indicates how long it took to execute that span. To analyze the duration we will look at several statistics and in particular percentiles. To learn more about percentiles and why you should use them instead of averages take a look at <a href="https://blog.timescale.com/blog/how-percentile-approximation-works-and-why-its-more-useful-than-averages/">our blog post on this subject</a>.</p><p>In this example, our goal is to write a query that will return one row per individual operation with several percentiles (99.9th, 99th, 95th) and the average of the duration in milliseconds. For this one we will search across root spans so we see which user requests have the worse response time:</p><pre><code>SELECT
    service_name,
    span_name as operation,
    ROUND(approx_percentile(0.999, percentile_agg(duration_ms))::numeric, 3) as duration_p999,
    ROUND(approx_percentile(0.99, percentile_agg(duration_ms))::numeric, 3) as duration_p99,
    ROUND(approx_percentile(0.95, percentile_agg(duration_ms))::numeric, 3) as duration_p95,
    ROUND(avg(duration_ms)::numeric, 3) as duration_avg
FROM span
WHERE
    start_time &gt; NOW() - INTERVAL &#39;1 hour&#39; AND
    parent_span_id = 0
GROUP BY service_name, operation
ORDER BY duration_p99 DESC
LIMIT 10;
</code></pre>
<p>This query uses TimescaleDB‚Äôs <a href="https://docs.timescale.com/api/latest/hyperfunctions/percentile-approximation/approx_percentile/"><code>approx_percentile</code> hyperfunction</a> to calculate the different percentiles. You could write the same query using PostgreSQL‚Äôs native <code>precentile_cont</code> function. However, <code>approx_percentile</code> is faster than <code>percentile_cont</code> while incurring a small error (less than 3%). With our test data, approx_percentile performs 35% faster than <code>percentile_cont</code> with minimal error (less than 3%). If you need more precision, you can decrease the error at the expense of lower performance by replacing <a href="https://docs.timescale.com/api/latest/hyperfunctions/percentile-approximation/percentile_agg/"><code>percentile_agg</code></a> with <a href="https://docs.timescale.com/api/latest/hyperfunctions/percentile-approximation/percentile-aggregation-methods/uddsketch/#required-arguments"><code>uddsketch</code></a>.</p><p>We use the <code>ROUND</code> function to limit the number of decimals shown in each column. We need to use <em>::numeric</em> to convert the return value of <code>approx_percentile</code> which is double precision to a type supported by the <code>ROUND</code> function, numeric in this case.</p><pre><code> service_name |              operation              | duration_p99 | duration_p999 | duration_p95 | duration_avg
--------------+-------------------------------------+--------------+---------------+--------------+--------------
 frontend     | /cart/checkout                      |    20658.359 |     20658.359 |     1238.359 |      600.609
 adservice    | AdService.start                     |    13319.743 |     13319.743 |    13319.743 |    13307.008
 cart         | grpc.health.v1.Health/Check         |     1843.628 |      1843.628 |      911.864 |      132.689
 frontend     | /                                   |     1159.651 |      1159.651 |      673.087 |      286.100
 frontend     | /product/{id}                       |      752.567 |       752.567 |      307.197 |      118.877
 frontend     | /cart                               |      582.594 |       582.594 |      270.289 |       92.472
 checkout     | hipstershop.CurrencyService/Convert |      193.229 |       193.229 |      101.888 |       30.177
 frontend     | /setCurrency                        |        7.504 |         7.504 |        0.908 |        0.498
 payment      | grpc.grpc.health.v1.Health/Check    |        1.615 |         1.615 |        0.172 |        0.386
 currency     | grpc.grpc.health.v1.Health/Check    |        1.355 |         1.355 |        0.140 |        0.420
</code></pre>
<p>If we look at the results we can for example quickly see that there seems to be an issue with the /cart/checkout endpoint. Note that if we just looked at the average we would think performance is good (600 ms). Even if we look at the 95% percentile performance still looks acceptable at 1.2 seconds. However, when we look at the 99% percentile we can see the performance is extremely poor (20 seconds). So somewhere in between 1% and 5% of the requests delivered a very poor user experience. This is definitely something worth investigating further.</p><p>As we can see, the results of the query are showing the performance of automated health checks. That may be useful in some scenarios but it‚Äôs not something our users experience and we may want to filter them out. To do it we would just add an additional condition to the where clause:</p><pre><code>start_time &gt; NOW() - INTERVAL &#39;1 hour&#39; AND
parent_span_id = 0 AND
span_name NOT LIKE &#39;%health%&#39;
</code></pre>
<p><strong>Query 3: Identify what services generate more load on other services by operation in the last 30 minutes</strong></p><p>In microservice architectures, there are many internal calls between services. One of those microservices could be going through a lot of load. That may be a service that is used by several other services for performing different operations and we would not immediately know what‚Äôs causing that.</p><p>Using the query below we can quickly list all dependencies across services and get an understanding of not only who is calling who and how often, but also what are the specific operations involved in those calls and how long the execution of those calls is taking in aggregate (in seconds). This serves as an additional indicator of load since some types of requests could be much more expensive than others.</p><pre><code>SELECT
    client_span.service_name AS client_service,
    server_span.service_name AS server_service,
    server_span.span_name AS server_operation,
    count(*) AS number_of_requests,
    ROUND(sum(server_span.duration_ms)::numeric) AS total_exec_time
FROM
    span AS server_span
    JOIN span AS client_span
    ON server_span.parent_span_id = client_span.span_id
WHERE
    client_span.start_time &gt; NOW() - INTERVAL &#39;30 minutes&#39; AND
    client_span.service_name != server_span.service_name
GROUP BY
    client_span.service_name,
    server_span.service_name,
    server_span.span_name
ORDER BY
    server_service,
    server_operation,
    number_of_requests DESC;
</code></pre>
<p>In this query we are leveraging another powerful capability of SQL: joins. We are joining the span table with itself to identify only the spans that represent a call between two services. This is what the condition <code>client_span.service_name != server_span.service_name</code> accomplishes.</p><p>The result would look something like the following:</p><pre><code> client_service | server_service |                    server_operation                     | number_of_requests | total_exec_time
----------------+----------------+---------------------------------------------------------+--------------------+-----------------
 frontend       | adservice      | hipstershop.AdService/GetAds                            |               2672 |               1
 frontend       | cart           | hipstershop.CartService/AddItem                         |                509 |               5
 checkout       | cart           | hipstershop.CartService/EmptyCart                       |                174 |               2
 frontend       | cart           | hipstershop.CartService/GetCart                         |               3697 |              25
 checkout       | cart           | hipstershop.CartService/GetCart                         |                174 |               2
 frontend       | checkout       | hipstershop.CheckoutService/PlaceOrder                  |                174 |              57
 frontend       | currency       | grpc.hipstershop.CurrencyService/Convert                |               8635 |              14
 checkout       | currency       | grpc.hipstershop.CurrencyService/Convert                |                408 |               1
 frontend       | currency       | grpc.hipstershop.CurrencyService/GetSupportedCurrencies |               3876 |               3
 checkout       | email          | /hipstershop.EmailService/SendOrderConfirmation         |                174 |               0
 checkout       | payment        | grpc.hipstershop.PaymentService/Charge                  |                174 |               0
 frontend       | productcatalog | hipstershop.ProductCatalogService/GetProduct            |              20436 |               1
 checkout       | productcatalog | hipstershop.ProductCatalogService/GetProduct            |                234 |               0
 frontend       | productcatalog | hipstershop.ProductCatalogService/ListProducts          |                501 |               0
 frontend       | recommendation | /hipstershop.RecommendationService/ListRecommendations  |               3374 |              15
 frontend       | shipping       | hipstershop.ShippingService/GetQuote                    |               1027 |               0
 checkout       | shipping       | hipstershop.ShippingService/GetQuote                    |                174 |               0
 checkout       | shipping       | hipstershop.ShippingService/ShipOrder                   |                174 |               0
</code></pre>
<p>These results show the client service making the request in the first column and the service and operation receiving the request in the second and third columns. We see for example that the GetProduct method of the ProductCatalogService has been called from the frontend service and the checkout service and that the former made many more calls in the last 30 minutes, which is expected and not an issue in this case. But if we saw a much higher percentage of calls to the GetProduct method originating from the checkout service this would be an indicator of something unexpected going on.</p><h2 id="conclusion">Conclusion</h2><p>Traces are extremely useful to troubleshoot and understand modern distributed systems. They help us answer questions that are impossible or very hard to answer with just metrics and logs. Adoption of traces has been traditionally slow because trace instrumentation has required a lot of manual effort and existing observability tools have not allowed us to query the data in flexible ways to get all the value traces can provide.</p><p>This is not true anymore thanks to OpenTelemetry and Promscale.</p><p>OpenTelemetry is quickly becoming <em>the</em> instrumentation standard and it offers libraries that automate (or at the very least simplify) trace instrumentation dramatically reducing the amount of effort required to instrument our services. Additionally, the instrumentation is vendor agnostic and the traces it generates can be sent to any compatible observability backend so we can change backends or use multiple ones.</p><p>Promscale is the observability backend with full SQL support for querying traces and metrics. With Promscale you can interrogate your data to answer any question you need to answer.</p><p>The combined power of OpenTelemetry and Promscale help you get more value out of traces and build better software.</p><h3 id="get-started-with-promscale">Get started with Promscale</h3><p>To start getting more value out of your traces and metrics with Promscale:</p><ul><li><strong><a href="https://github.com/timescale/promscale/blob/master/docs/tracing.md">Check out our tracing documentation</a> </strong>for more details on how to start collecting traces with OpenTelemetry, Jaeger, and Zipkin and how to visualize them in Jaeger and Grafana.</li><li><strong>Read our </strong><a href="https://docs.timescale.com/latest/tutorials/getting-started-with-promscale"><strong>Getting Started with Promscale and Prometheus tutorial</strong></a> for more on how Promscale works with Prometheus, installation instructions, sample PromQL and SQL queries, and more.</li><li><strong>Check our <a href="https://github.com/timescale/promscale#readme">Github repository</a></strong>. As a reminder, Promscale is open-source and completely free to use. (GitHub ‚≠êÔ∏è ¬†welcome and appreciated! üôè)</li><li><strong>Watch </strong><a href="https://www.youtube.com/playlist?list=PLsceB9ac9MHTrmU-q7WCEvies-o7ts3ps"><strong>Promscale 101 YouTube playlist</strong></a> for step-by-step demos and best practices.</li></ul><p>Whether you‚Äôre new to Promscale or an existing community member, we‚Äôd love to hear from you! <a href="https://slack.timescale.com/"><strong>Join TimescaleDB Slack</strong></a>, where you‚Äôll find 7K+ developers and Timescale engineers active in all channels. (The dedicated <em><a href="https://timescaledb.slack.com/archives/C011FC0PPC5">#promscale</a></em> channel has 2.5K+ members, so it‚Äôs a great place to connect with like-minded community members, ask questions, get advice, and more).</p>
      </div></div>